var m7PeerCalculagraph = null; var _topics = {}; var _loadedModules = {}; var opts = Object.prototype.toString; var xtor = new Function(); var cname = 'constructor'; var counter = 0; var softphoneBar = null; var phone = null; var monitor = null; var monitorTimers = []; var monitoring = null; var _cti_peerstate = null; var prePhonebarStatus = '0'; var isCtiRelogin = !1; var currentEventObj = {}; var isSuperAdmin = !1; var account = {}; function changePhoneBarStatus(t) { for (var e = 0; e < m7$('.userStatus').length; e++)m7$(m7$('.userStatus')[e]).css('color', '#8a8a8a'), m7$(m7$('.userStatus')[e]).find('span').css('background-color', '#8a8a8a'); t == '0' ? (m7$('#IdleDisable').css('color', '#53d466'), m7$('#IdleDisable').find('span').css('background-color', '#53d466'), m7$('.peerTimeState').css('color', '#53d466')) : t == '2' ? (m7$('#RestDisable').css('color', '#e3a42c'), m7$('#RestDisable').find('span').css('background-color', '#e3a42c'), m7$('.peerTimeState').css('color', '#e3a42c')) : t == '1' ? (m7$('#BusyDisable').css('color', '#ff7a72'), m7$('#BusyDisable').find('span').css('background-color', '#ff7a72'), m7$('.peerTimeState').css('color', '#ff7a72')) : (m7$('#userStatus_' + t).css('color', '#ff7a72'), m7$('#userStatus_' + t).find('span').css('background-color', '#ff7a72'), m7$('.peerTimeState').css('color', '#ff7a72'), m7$(m7$('.softphone_timer').find('span')[0]).css('color', '#ff7a72')) } function senvenProvide(t) { return _loadedModules[t += ''] = sevenGetObject(t, !0) } function senvenMPublish(t, e) { t = _topics[t]; t && t.apply(this, e || []) } function senvenMSubscribe(t, e, r) { return [t, _listener.add(_topics, t, moor.hitch(e, r))] } function sevenMUsubscribe(t) { t && _listener.remove(_topics, t[0], t[1]) } function senvenGetIndexof(t, e, r, n) { var o = 1; var s = t.length || 0; var i = 0; if (n && (i = s - 1, o = s = -1), r != null && (i = r), n && s < i || i < s) for (;i != s; i += o) if (t[i] == e) return i; return -1 } function sevenContent(t, e, r, n, o) { var s = arguments; var i = []; var a = 0; i.push(isString(s[0]) ? null : s[a++], s[a++]); var c = s[a + 1]; i.push(isString(c) || isFunction(c) ? s[a++] : null, s[a++]); for (var l = s.length; a < l; a++)i.push(s[a]); return _connect.apply(this, i) } function isFunction(t) { return Object.prototype.toString.call(t) === '[object Function]' } function isString(t) { return typeof t === 'string' || t instanceof String } function _connect(t, e, r, n) { var o = _listener; return [t, e, o.add(t, e, moor.hitch(r, n)), o] } function sevenGetObject(t, e, r) { return _getProp(t.split('.'), e, r) } function _getProp(t, e, r) { for (var n, o = r || moor.global, s = 0; o && (n = t[s]); s++)o = (n = s == 0 && moor._scopeMap[n] ? moor._scopeMap[n] : n) in o ? o[n] : e ? o[n] = {} : void 0; return o } function sevenDeclare(t, e, r) { typeof t !== 'string' && (r = e, e = t, t = ''), r = r || {}; var n; var o; var s; var i; var a; var c; var l; var p = 1; var u = e; if (opts.call(e) == '[object Array]' ? (s = (c = c3mro(e, t))[0], e = c[p = c.length - s]) : (c = [0], e ? opts.call(e) == '[object Function]' ? (s = e._meta, c = c.concat(s ? s.bases : e)) : err('base class is not a callable constructor.', t) : e !== null && err('unknown base class. Did you use moor.require to pull it in?', t)), e) for (o = p - 1; n = forceNew(e), o; --o)((s = c[o])._meta ? mixOwn : moor._mixin)(n, s.prototype), (i = new Function()).superclass = e, e = (i.prototype = n).constructor = i; else n = {}; for (safeMixin(n, r), (s = r.constructor) !== Object.prototype.constructor && (s.nom = cname, n.constructor = s), o = p - 1; o; --o)(s = c[o]._meta) && s.chains && (l = moor._mixin(l || {}, s.chains)); if (s = !(l = n['-chains-'] ? moor._mixin(l || {}, n['-chains-']) : l) || !l.hasOwnProperty(cname), c[0] = i = l && l.constructor === 'manual' ? simpleConstructor(c) : c.length == 1 ? singleConstructor(r.constructor, s) : chainedConstructor(c, s), i._meta = { bases: c, hidden: r, chains: l, parents: u, ctor: r.constructor }, i.superclass = e && e.prototype, i.extend = extend, (i.prototype = n).constructor = i, n.getInherited = getInherited, n.inherited = inherited, n.isInstanceOf = isInstanceOf, t && setObject(n.declaredClass = t, i), l) for (a in l)n[a] && typeof l[a] === 'string' && a != cname && ((s = n[a] = chain(a, c, l[a] === 'after')).nom = a); return i } function err(t, e) { throw new Error('declare' + (e ? ' ' + e : '') + ': ' + t) } function extend(t) { return safeMixin(this.prototype, t), this } function setObject(t, e, r) { var n = t.split('.'); var t = n.pop(); var r = _getProp(n, !0, r); return r && t ? r[t] = e : void 0 } function getInherited(t, e) { return typeof t === 'string' ? this.inherited(t, e, !0) : this.inherited(t, !0) } function chain(o, s, i) { return function() { var t; var e; var r = 0; var n = 1; for (i && (r = s.length - 1, n = -1); e = s[r]; r += n)(e = ((t = e._meta) ? t.hidden : e.prototype)[o]) && e.apply(this, arguments) } } function isInstanceOf(t) { for (var e = this.constructor._meta.bases, r = 0, n = e.length; r < n; ++r) if (e[r] === t) return !0; return this instanceof t } function inherited(t, e, r) { var n; var o; var s; var i; var a; var c; var l; var p; var u; var f = this._inherited = this._inherited || {}; if (typeof t === 'string' && (n = t, t = e, e = r), r = 0, i = t.callee, (n = n || i.nom) || err("can't deduce a name to call inherited()", this.declaredClass), s = (a = this.constructor._meta).bases, u = f.p, n != cname) { if (f.c !== i && (a = (c = s[u = 0])._meta).hidden[n] !== i) { (o = a.chains) && typeof o[n] === 'string' && err('calling chained method with inherited: ' + n, this.declaredClass); do { if (a = c._meta, l = c.prototype, a && (l[n] === i && l.hasOwnProperty(n) || a.hidden[n] === i)) break } while (c = s[++u]);u = c ? u : -1 } if (c = s[++u]) if (l = c.prototype, c._meta && l.hasOwnProperty(n))r = l[n]; else { p = Object.prototype[n]; do { if ((r = (l = c.prototype)[n]) && (c._meta ? l.hasOwnProperty(n) : r !== p)) break } while (c = s[++u]) }r = c && r || Object.prototype[n] } else { if (f.c !== i && (a = s[u = 0]._meta) && a.ctor !== i) { for ((o = a.chains) && o.constructor === 'manual' || err('calling chained constructor with inherited', this.declaredClass); (c = s[++u]) && (!(a = c._meta) || a.ctor !== i););u = c ? u : -1 } for (;(c = s[++u]) && !(r = (a = c._meta) ? a.ctor : c););r = c && r } if (f.c = r, f.p = u, r) return !0 === e ? r : r.apply(this, e || t) } function safeMixin(t, e) { var r; var n; var o = 0; var s = extraNames.length; for (r in e)(n = e[r]) === Object.prototype[r] && r in Object.prototype || r == cname || (opts.call(n) == '[object Function]' && (n.nom = r), t[r] = n); for (;o < s; ++o)(n = e[r = extraNames[o]]) === Object.prototype[r] && r in Object.prototype || r == cname || (opts.call(n) == '[object Function]' && (n.nom = r), t[r] = n); return t } function singleConstructor(o, s) { return function() { var t; var e = arguments; var r = e; var n = e[0]; if (!(this instanceof e.callee)) return applyNew(e); s && (n && (t = n.preamble) && (r = t.apply(this, r) || r), (t = this.preamble) && t.apply(this, r)), o && o.apply(this, e), (t = this.postscript) && t.apply(this, e) } } function chainedConstructor(c, l) { return function() { var t; var e; var r; var n; var o = arguments; var s = o; var i = o[0]; var a = c.length; if (!(this instanceof o.callee)) return applyNew(o); if (l && (i && i.preamble || this.preamble)) for ((n = new Array(c.length))[0] = o, e = 0; (i = o[0]) && (t = i.preamble) && (o = t.apply(this, o) || o), (t = (t = c[e].prototype).hasOwnProperty('preamble') && t.preamble) && (o = t.apply(this, o) || o), ++e != a;)n[e] = o; for (e = a - 1; e >= 0; --e)(t = (r = (t = c[e])._meta) ? r.ctor : t) && t.apply(this, n ? n[e] : o); (t = this.postscript) && t.apply(this, s) } } function simpleConstructor(o) { return function() { var t; var e; var r = arguments; var n = 0; if (!(this instanceof r.callee)) return applyNew(r); for (;t = o[n]; ++n) if (t = (e = t._meta) ? e.ctor : t) { t.apply(this, r); break }(t = this.postscript) && t.apply(this, r) } } function applyNew(t) { var e = t.callee; var r = forceNew(e); return e.apply(r, t), r } function forceNew(t) { xtor.prototype = t.prototype; new (new Function())(); xtor.prototype = null } function extraNames() { var t, e; for (e in { toString: 1 }) { t = []; break } return t || ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'] } function mixOwn(t, e) { var r; var n = 0; var o = extraNames.length; for (r in e)r != cname && e.hasOwnProperty(r) && (t[r] = e[r]); for (;n < o; ++n)(r = extraNames[n]) != cname && e.hasOwnProperty(r) && (t[r] = e[r]) } function c3mro(t, e) { for (var r, n, o, s, i, a, c = [], l = [{ cls: 0, refs: [] }], p = {}, u = 1, f = t.length, h = 0; h < f; ++h) { for ((o = t[h]) ? opts.call(o) != '[object Function]' && err('mixin #' + h + ' is not a callable constructor.', e) : err('mixin #' + h + ' is unknown. Did you use moor.require to pull it in?', e), s = 0, r = (n = o._meta ? o._meta.bases : [o]).length - 1; r >= 0; --r)(i = n[r].prototype).hasOwnProperty('declaredClass') || (i.declaredClass = 'uniqName_' + counter++), i = i.declaredClass, p.hasOwnProperty(i) || (p[i] = { count: 0, refs: [], cls: n[r] }, ++u), i = p[i], s && s !== i && (i.refs.push(s), ++s.count), s = i; ++s.count, l[0].refs.push(s) } for (;l.length;) { for (s = l.pop(), c.push(s.cls), --u; (a = s.refs).length == 1;) { if (!(s = a[0]) || --s.count) { s = 0; break }c.push(s.cls), --u } if (s) for (h = 0, f = a.length; h < f; ++h)--(s = a[h]).count || l.push(s) } return u && err("can't build consistent linearization", e), o = t[0], c[0] = o ? o._meta && o === c[c.length - o._meta.bases.length] ? o._meta.bases.length : 1 : 0, c } var _listener = { getDispatcher: function() { return function() { var t; var e = Array.prototype; var r = arguments.callee; var n = r._listeners; var r = r.target; var r = r && r.apply(this, arguments); var o = [].concat(n); for (t in o)t in e || o[t].apply(this, arguments); return r } }, add: function(t, e, r) { var n; var o = (t = t || moor.global)[e]; return o && o._listeners || ((n = _listener.getDispatcher()).target = o, n._listeners = [], o = t[e] = n), o._listeners.push(r) }, remove: function(t, e, r) { e = (t || moor.global)[e]; e && e._listeners && r-- && delete e._listeners[r] } }
