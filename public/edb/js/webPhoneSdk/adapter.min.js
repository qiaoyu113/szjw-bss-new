!(function(e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define([], e) : (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).adapter = e() }(function() { return (function n(i, a, o) { function s(t, e) { if (!a[t]) { if (!i[t]) { var r = typeof require === 'function' && require; if (!e && r) return r(t, !0); if (c) return c(t, !0); r = new Error("Cannot find module '" + t + "'"); throw r.code = 'MODULE_NOT_FOUND', r }r = a[t] = { exports: {} }; i[t][0].call(r.exports, function(e) { return s(i[t][1][e] || e) }, r, r.exports, n, i, a, o) } return a[t].exports } for (var c = typeof require === 'function' && require, e = 0; e < o.length; e++)s(o[e]); return s }({ 1: [function(e, t, r) { 'use strict'; function s(e, t, r, n) { t = O.writeRtpDescription(e.kind, t); return t += O.writeIceParameters(e.iceGatherer.getLocalParameters()), t += O.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === 'offer' ? 'actpass' : 'active'), t += 'a=mid:' + e.mid + '\r\n', e.direction ? t += 'a=' + e.direction + '\r\n' : e.rtpSender && e.rtpReceiver ? t += 'a=sendrecv\r\n' : e.rtpSender ? t += 'a=sendonly\r\n' : e.rtpReceiver ? t += 'a=recvonly\r\n' : t += 'a=inactive\r\n', e.rtpSender && (t += 'a=' + (n = 'msid:' + n.id + ' ' + e.rtpSender.track.id + '\r\n'), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + n, e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + n, t += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n')), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + O.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + O.localCName + '\r\n'), t } function l(n, i) { function a(e, t) { e = parseInt(e, 10); for (var r = 0; r < t.length; r++) if (t[r].payloadType === e || t[r].preferredPayloadType === e) return t[r] } var o = { codecs: [], headerExtensions: [], fecMechanisms: [] }; return n.codecs.forEach(function(r) { for (var e = 0; e < i.codecs.length; e++) { var t = i.codecs[e]; if (r.name.toLowerCase() === t.name.toLowerCase() && r.clockRate === t.clockRate && (r.name.toLowerCase() !== 'rtx' || !r.parameters || !t.parameters.apt || (function(e, t, r, n) { r = a(e.parameters.apt, r), n = a(t.parameters.apt, n); return r && n && r.name.toLowerCase() === n.name.toLowerCase() }(r, t, n.codecs, i.codecs)))) { (t = JSON.parse(JSON.stringify(t))).numChannels = Math.min(r.numChannels, t.numChannels), o.codecs.push(t), t.rtcpFeedback = t.rtcpFeedback.filter(function(e) { for (var t = 0; t < r.rtcpFeedback.length; t++) if (r.rtcpFeedback[t].type === e.type && r.rtcpFeedback[t].parameter === e.parameter) return !0; return !1 }); break } } }), n.headerExtensions.forEach(function(e) { for (var t = 0; t < i.headerExtensions.length; t++) { var r = i.headerExtensions[t]; if (e.uri === r.uri) { o.headerExtensions.push(r); break } } }), o } function a(e, t, r) { return { offer: { setLocalDescription: ['stable', 'have-local-offer'], setRemoteDescription: ['stable', 'have-remote-offer'] }, answer: { setLocalDescription: ['have-remote-offer', 'have-local-pranswer'], setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'] } }[t][e].indexOf(r) !== -1 } function _(e, t) { e.getRemoteCandidates().find(function(e) { return t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type }) || e.addRemoteCandidate(t) } var O = e('sdp'); t.exports = function(k, x) { function e(e) { var n; var i; var t = this; var r = document.createDocumentFragment(); if (['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function(e) { t[e] = r[e].bind(r) }), this.onicecandidate = null, this.onaddstream = null, this.ontrack = null, this.onremovestream = null, this.onsignalingstatechange = null, this.oniceconnectionstatechange = null, this.onicegatheringstatechange = null, this.onnegotiationneeded = null, this.ondatachannel = null, this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this.localDescription = null, this.remoteDescription = null, this.signalingState = 'stable', this.iceConnectionState = 'new', this.iceGatheringState = 'new', e = JSON.parse(JSON.stringify(e || {})), this.usingBundle = e.bundlePolicy === 'max-bundle', e.rtcpMuxPolicy === 'negotiate') { var a = new Error("rtcpMuxPolicy 'negotiate' is not supported"); throw a.name = 'NotSupportedError', a } switch (e.rtcpMuxPolicy || (e.rtcpMuxPolicy = 'require'), e.iceTransportPolicy) { case 'all':case 'relay':break; default:e.iceTransportPolicy = 'all' } switch (e.bundlePolicy) { case 'balanced':case 'max-compat':case 'max-bundle':break; default:e.bundlePolicy = 'balanced' } if (e.iceServers = (a = e.iceServers || [], n = x, i = !1, (a = JSON.parse(JSON.stringify(a))).filter(function(e) { if (e && (e.urls || e.url)) { var t = e.urls || e.url; e.url && !e.urls && console.warn('RTCIceServer.url is deprecated! Use urls instead.'); var r = typeof t === 'string'; var t = (t = r ? [t] : t).filter(function(e) { return e.indexOf('turn:') !== 0 || e.indexOf('transport=udp') === -1 || e.indexOf('turn:[') !== -1 || i ? e.indexOf('stun:') === 0 && n >= 14393 && e.indexOf('?transport=udp') === -1 : i = !0 }); return delete e.url, e.urls = r ? t[0] : t, !!t.length } return !1 })), this._iceGatherers = [], e.iceCandidatePoolSize) for (var o = e.iceCandidatePoolSize; o > 0; o--) this._iceGatherers = new k.RTCIceGatherer({ iceServers: e.iceServers, gatherPolicy: e.iceTransportPolicy }); else e.iceCandidatePoolSize = 0; this._config = e, this.transceivers = [], this._sdpSessionId = O.generateSessionId(), this._sdpSessionVersion = 0 } return e.prototype._emitGatheringStateChange = function() { var e = new Event('icegatheringstatechange'); this.dispatchEvent(e), this.onicegatheringstatechange !== null && this.onicegatheringstatechange(e) }, e.prototype.getConfiguration = function() { return this._config }, e.prototype.getLocalStreams = function() { return this.localStreams }, e.prototype.getRemoteStreams = function() { return this.remoteStreams }, e.prototype._createTransceiver = function(e) { var t = this.transceivers.length > 0; var e = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, wantReceive: !0 }; return this.usingBundle && t ? (e.iceTransport = this.transceivers[0].iceTransport, e.dtlsTransport = this.transceivers[0].dtlsTransport) : (t = this._createIceAndDtlsTransports(), e.iceTransport = t.iceTransport, e.dtlsTransport = t.dtlsTransport), this.transceivers.push(e), e }, e.prototype.addTrack = function(e, t) { for (var r, n = 0; n < this.transceivers.length; n++) this.transceivers[n].track || this.transceivers[n].kind !== e.kind || (r = this.transceivers[n]); return r = r || this._createTransceiver(e.kind), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(t) === -1 && this.localStreams.push(t), r.track = e, r.stream = t, r.rtpSender = new k.RTCRtpSender(e, r.dtlsTransport), r.rtpSender }, e.prototype.addStream = function(t) { var n; var r = this; x >= 15025 ? t.getTracks().forEach(function(e) { r.addTrack(e, t) }) : (n = t.clone(), t.getTracks().forEach(function(e, t) { var r = n.getTracks()[t]; e.addEventListener('enabled', function(e) { r.enabled = e.enabled }) }), n.getTracks().forEach(function(e) { r.addTrack(e, n) })) }, e.prototype.removeStream = function(e) { e = this.localStreams.indexOf(e); e > -1 && (this.localStreams.splice(e, 1), this._maybeFireNegotiationNeeded()) }, e.prototype.getSenders = function() { return this.transceivers.filter(function(e) { return !!e.rtpSender }).map(function(e) { return e.rtpSender }) }, e.prototype.getReceivers = function() { return this.transceivers.filter(function(e) { return !!e.rtpReceiver }).map(function(e) { return e.rtpReceiver }) }, e.prototype._createIceGatherer = function(r, e) { var n = this; if (e && r > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var i = new k.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(i, 'state', { value: 'new', writable: !0 }), this.transceivers[r].candidates = [], this.transceivers[r].bufferCandidates = function(e) { var t = !e.candidate || Object.keys(e.candidate).length === 0; i.state = t ? 'completed' : 'gathering', n.transceivers[r].candidates !== null && n.transceivers[r].candidates.push(e.candidate) }, i.addEventListener('localcandidate', this.transceivers[r].bufferCandidates), i }, e.prototype._gather = function(n, i) { var e; var a = this; var o = this.transceivers[i].iceGatherer; o.onlocalcandidate || (e = this.transceivers[i].candidates, this.transceivers[i].candidates = null, o.removeEventListener('localcandidate', this.transceivers[i].bufferCandidates), o.onlocalcandidate = function(e) { var t, r; a.usingBundle && i > 0 || ((t = new Event('icecandidate')).candidate = { sdpMid: n, sdpMLineIndex: i }, (e = !(r = e.candidate) || Object.keys(r).length === 0) ? o.state !== 'new' && o.state !== 'gathering' || (o.state = 'completed') : (o.state === 'new' && (o.state = 'gathering'), r.component = 1, t.candidate.candidate = O.writeCandidate(r)), (r = O.splitSections(a.localDescription.sdp))[t.candidate.sdpMLineIndex + 1] += e ? 'a=end-of-candidates\r\n' : 'a=' + t.candidate.candidate + '\r\n', a.localDescription.sdp = r.join(''), r = a.transceivers.every(function(e) { return e.iceGatherer && e.iceGatherer.state === 'completed' }), a.iceGatheringState !== 'gathering' && (a.iceGatheringState = 'gathering', a._emitGatheringStateChange()), e || (a.dispatchEvent(t), a.onicecandidate !== null && a.onicecandidate(t)), r && (a.dispatchEvent(new Event('icecandidate')), a.onicecandidate !== null && a.onicecandidate(new Event('icecandidate')), a.iceGatheringState = 'complete', a._emitGatheringStateChange())) }, k.setTimeout(function() { e.forEach(function(e) { var t = new Event('RTCIceGatherEvent'); t.candidate = e, o.onlocalcandidate(t) }) }, 0)) }, e.prototype._createIceAndDtlsTransports = function() { var e = this; var t = new k.RTCIceTransport(null); t.onicestatechange = function() { e._updateConnectionState() }; var r = new k.RTCDtlsTransport(t); return r.ondtlsstatechange = function() { e._updateConnectionState() }, r.onerror = function() { Object.defineProperty(r, 'state', { value: 'failed', writable: !0 }), e._updateConnectionState() }, { iceTransport: t, dtlsTransport: r } }, e.prototype._disposeIceAndDtlsTransports = function(e) { var t = this.transceivers[e].iceGatherer; t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer); t = this.transceivers[e].iceTransport; t && (delete t.onicestatechange, delete this.transceivers[e].iceTransport); t = this.transceivers[e].dtlsTransport; t && (delete t.ondtlsstatechange, delete t.onerror, delete this.transceivers[e].dtlsTransport) }, e.prototype._transceive = function(e, t, r) { var n = l(e.localCapabilities, e.remoteCapabilities); t && e.rtpSender && (n.encodings = e.sendEncodingParameters, n.rtcp = { cname: O.localCName, compound: e.rtcpParameters.compound }, e.recvEncodingParameters.length && (n.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(n)), r && e.rtpReceiver && (e.kind === 'video' && e.recvEncodingParameters && x < 15019 && e.recvEncodingParameters.forEach(function(e) { delete e.rtx }), n.encodings = e.recvEncodingParameters, n.rtcp = { cname: e.rtcpParameters.cname, compound: e.rtcpParameters.compound }, e.sendEncodingParameters.length && (n.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(n)) }, e.prototype.setLocalDescription = function(n) { var e; var d; var p; var u = this; var i = arguments; if (!a('setLocalDescription', n.type, this.signalingState)) return new Promise(function(e, t) { var r = new Error('Can not set remote ' + n.type + ' in state ' + u.signalingState); r.name = 'InvalidStateError', i.length > 2 && typeof i[2] === 'function' && i[2].apply(null, [r]), t(r) }); switch (n.type === 'offer' ? (e = O.splitSections(n.sdp), d = e.shift(), e.forEach(function(e, t) { e = O.parseRtpParameters(e); u.transceivers[t].localCapabilities = e }), this.transceivers.forEach(function(e, t) { u._gather(e.mid, t) })) : n.type === 'answer' && (e = O.splitSections(u.remoteDescription.sdp), d = e.shift(), p = O.matchPrefix(d, 'a=ice-lite').length > 0, e.forEach(function(e, t) { var r; var n = u.transceivers[t]; var i = n.iceGatherer; var a = n.iceTransport; var o = n.dtlsTransport; var s = n.localCapabilities; var c = n.remoteCapabilities; O.isRejected(e) || n.isDatachannel || (r = O.getIceParameters(e, d), e = O.getDtlsParameters(e, d), p && (e.role = 'server'), u.usingBundle && t !== 0 || (u._gather(n.mid, t), a.state === 'new' && a.start(i, r, p ? 'controlling' : 'controlled'), o.state === 'new' && o.start(e)), c = l(s, c), u._transceive(n, c.codecs.length > 0, !1)) })), this.localDescription = { type: n.type, sdp: n.sdp }, n.type) { case 'offer':this._updateSignalingState('have-local-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + n.type + '"') } var t = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1]; return new Promise(function(e) { t && t.apply(null), e() }) }, e.prototype.setRemoteDescription = function(T) { var S = this; var n = arguments; if (!a('setRemoteDescription', T.type, this.signalingState)) return new Promise(function(e, t) { var r = new Error('Can not set remote ' + T.type + ' in state ' + S.signalingState); r.name = 'InvalidStateError', n.length > 2 && typeof n[2] === 'function' && n[2].apply(null, [r]), t(r) }); var P = {}; this.remoteStreams.forEach(function(e) { P[e.id] = e }); var b = []; var e = O.splitSections(T.sdp); var R = e.shift(); var E = O.matchPrefix(R, 'a=ice-lite').length > 0; var w = O.matchPrefix(R, 'a=group:BUNDLE ').length > 0; this.usingBundle = w; var t = O.matchPrefix(R, 'a=ice-options:')[0]; switch (this.canTrickleIceCandidates = !!t && t.substr(14).split(' ').indexOf('trickle') >= 0, e.forEach(function(e, t) { var r; var n; var i; var a; var o; var s; var c; var d; var p; var u; var l; var f = O.splitLines(e); var m = O.getKind(e); var h = O.isRejected(e); var v = f[0].substr(2).split(' ')[2]; var g = O.getDirection(e, R); var y = O.parseMsid(e); var C = O.getMid(e) || O.generateIdentifier(); m !== 'application' || v !== 'DTLS/SCTP' ? (s = O.parseRtpParameters(e), h || (a = O.getIceParameters(e, R), (o = O.getDtlsParameters(e, R)).role = 'client'), n = O.parseRtpEncodingParameters(e), c = O.parseRtcpParameters(e), d = O.matchPrefix(e, 'a=end-of-candidates', R).length > 0, f = O.matchPrefix(e, 'a=candidate:').map(function(e) { return O.parseCandidate(e) }).filter(function(e) { return e.component === 1 }), (T.type === 'offer' || T.type === 'answer') && !h && w && t > 0 && S.transceivers[t] && (S._disposeIceAndDtlsTransports(t), S.transceivers[t].iceGatherer = S.transceivers[0].iceGatherer, S.transceivers[t].iceTransport = S.transceivers[0].iceTransport, S.transceivers[t].dtlsTransport = S.transceivers[0].dtlsTransport, S.transceivers[t].rtpSender && S.transceivers[t].rtpSender.setTransport(S.transceivers[0].dtlsTransport), S.transceivers[t].rtpReceiver && S.transceivers[t].rtpReceiver.setTransport(S.transceivers[0].dtlsTransport)), T.type !== 'offer' || h ? T.type !== 'answer' || h || (v = (l = S.transceivers[t]).iceGatherer, e = l.iceTransport, h = l.dtlsTransport, u = l.rtpReceiver, r = l.sendEncodingParameters, i = l.localCapabilities, S.transceivers[t].recvEncodingParameters = n, S.transceivers[t].remoteCapabilities = s, S.transceivers[t].rtcpParameters = c, f.length && (!E && !d || w && t !== 0 || e.state !== 'new' ? f.forEach(function(e) { _(l.iceTransport, e) }) : e.setRemoteCandidates(f)), w && t !== 0 || (e.state === 'new' && e.start(v, a, 'controlling'), h.state === 'new' && h.start(o)), S._transceive(l, g === 'sendrecv' || g === 'recvonly', g === 'sendrecv' || g === 'sendonly'), !u || g !== 'sendrecv' && g !== 'sendonly' ? delete l.rtpReceiver : (p = u.track, y ? (P[y.stream] || (P[y.stream] = new k.MediaStream()), P[y.stream].addTrack(p), b.push([p, u, P[y.stream]])) : (P.default || (P.default = new k.MediaStream()), P.default.addTrack(p), b.push([p, u, P.default])))) : ((l = S.transceivers[t] || S._createTransceiver(m)).mid = C, l.iceGatherer || (l.iceGatherer = S._createIceGatherer(t, w)), f.length && (!d || w && t !== 0 || l.iceTransport.state !== 'new' ? f.forEach(function(e) { _(l.iceTransport, e) }) : l.iceTransport.setRemoteCandidates(f)), i = k.RTCRtpReceiver.getCapabilities(m), x < 15019 && (i.codecs = i.codecs.filter(function(e) { return e.name !== 'rtx' })), r = [{ ssrc: 1001 * (2 * t + 2) }], g !== 'sendrecv' && g !== 'sendonly' || (f = !l.rtpReceiver, u = l.rtpReceiver || new k.RTCRtpReceiver(l.dtlsTransport, m), f && (p = u.track, (f = y ? (P[y.stream] || (P[y.stream] = new k.MediaStream(), Object.defineProperty(P[y.stream], 'id', { get: function() { return y.stream } })), Object.defineProperty(p, 'id', { get: function() { return y.track } }), P[y.stream]) : (P.default || (P.default = new k.MediaStream()), P.default)).addTrack(p), b.push([p, u, f]))), l.localCapabilities = i, l.remoteCapabilities = s, l.rtpReceiver = u, l.rtcpParameters = c, l.sendEncodingParameters = r, l.recvEncodingParameters = n, S._transceive(S.transceivers[t], !1, g === 'sendrecv' || g === 'sendonly'))) : S.transceivers[t] = { mid: C, isDatachannel: !0 } }), this.remoteDescription = { type: T.type, sdp: T.sdp }, T.type) { case 'offer':this._updateSignalingState('have-remote-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + T.type + '"') } return Object.keys(P).forEach(function(e) { var t; var i = P[e]; i.getTracks().length && (S.remoteStreams.indexOf(i) === -1 && (S.remoteStreams.push(i), (t = new Event('addstream')).stream = i, k.setTimeout(function() { S.dispatchEvent(t), S.onaddstream !== null && S.onaddstream(t) })), b.forEach(function(e) { var t; var r = e[0]; var n = e[1]; i.id === e[2].id && ((t = new Event('track')).track = r, t.receiver = n, t.transceiver = { receiver: n }, t.streams = [i], k.setTimeout(function() { S.dispatchEvent(t), S.ontrack !== null && S.ontrack(t) })) })) }), k.setTimeout(function() { S && S.transceivers && S.transceivers.forEach(function(e) { e.iceTransport && e.iceTransport.state === 'new' && e.iceTransport.getRemoteCandidates().length > 0 && (console.warn('Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification'), e.iceTransport.addRemoteCandidate({})) }) }, 4e3), new Promise(function(e) { n.length > 1 && typeof n[1] === 'function' && n[1].apply(null), e() }) }, e.prototype.close = function() { this.transceivers.forEach(function(e) { e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop() }), this._updateSignalingState('closed') }, e.prototype._updateSignalingState = function(e) { this.signalingState = e; e = new Event('signalingstatechange'); this.dispatchEvent(e), this.onsignalingstatechange !== null && this.onsignalingstatechange(e) }, e.prototype._maybeFireNegotiationNeeded = function() { var t = this; this.signalingState === 'stable' && !0 !== this.needNegotiation && (this.needNegotiation = !0, k.setTimeout(function() { var e; !1 !== t.needNegotiation && (t.needNegotiation = !1, e = new Event('negotiationneeded'), t.dispatchEvent(e), t.onnegotiationneeded !== null && t.onnegotiationneeded(e)) }, 0)) }, e.prototype._updateConnectionState = function() { var e; var t = { new: 0, closed: 0, connecting: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; this.transceivers.forEach(function(e) { t[e.iceTransport.state]++, t[e.dtlsTransport.state]++ }), t.connected += t.completed, e = 'new', t.failed > 0 ? e = 'failed' : t.connecting > 0 || t.checking > 0 ? e = 'connecting' : t.disconnected > 0 ? e = 'disconnected' : t.new > 0 ? e = 'new' : (t.connected > 0 || t.completed > 0) && (e = 'connected'), e !== this.iceConnectionState && (this.iceConnectionState = e, e = new Event('iceconnectionstatechange'), this.dispatchEvent(e), this.oniceconnectionstatechange !== null && this.oniceconnectionstatechange(e)) }, e.prototype.createOffer = function() { var e; var o = this; var t = arguments; arguments.length === 1 && typeof arguments[0] !== 'function' ? e = arguments[0] : arguments.length === 3 && (e = arguments[2]); var r = this.transceivers.filter(function(e) { return e.kind === 'audio' }).length; var n = this.transceivers.filter(function(e) { return e.kind === 'video' }).length; if (e) { if (e.mandatory || e.optional) throw new TypeError('Legacy mandatory/optional constraints not supported.'); void 0 !== e.offerToReceiveAudio && (r = !0 === e.offerToReceiveAudio ? 1 : !1 === e.offerToReceiveAudio ? 0 : e.offerToReceiveAudio), void 0 !== e.offerToReceiveVideo && (n = !0 === e.offerToReceiveVideo ? 1 : !1 === e.offerToReceiveVideo ? 0 : e.offerToReceiveVideo) } for (this.transceivers.forEach(function(e) { e.kind === 'audio' ? --r < 0 && (e.wantReceive = !1) : e.kind === 'video' && --n < 0 && (e.wantReceive = !1) }); r > 0 || n > 0;)r > 0 && (this._createTransceiver('audio'), r--), n > 0 && (this._createTransceiver('video'), n--); var i = O.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++); this.transceivers.forEach(function(e, t) { var r = e.track; var n = e.kind; var i = O.generateIdentifier(); e.mid = i, e.iceGatherer || (e.iceGatherer = o._createIceGatherer(t, o.usingBundle)); var a = k.RTCRtpSender.getCapabilities(n); x < 15019 && (a.codecs = a.codecs.filter(function(e) { return e.name !== 'rtx' })), a.codecs.forEach(function(e) { e.name === 'H264' && void 0 === e.parameters['level-asymmetry-allowed'] && (e.parameters['level-asymmetry-allowed'] = '1') }); i = [{ ssrc: 1001 * (2 * t + 1) }]; r && x >= 15019 && n === 'video' && (i[0].rtx = { ssrc: 1001 * (2 * t + 1) + 1 }), e.wantReceive && (e.rtpReceiver = new k.RTCRtpReceiver(e.dtlsTransport, n)), e.localCapabilities = a, e.sendEncodingParameters = i }), this._config.bundlePolicy !== 'max-compat' && (i += 'a=group:BUNDLE ' + this.transceivers.map(function(e) { return e.mid }).join(' ') + '\r\n'), i += 'a=ice-options:trickle\r\n', this.transceivers.forEach(function(e, t) { i += s(e, e.localCapabilities, 'offer', e.stream), i += 'a=rtcp-rsize\r\n', !e.iceGatherer || o.iceGatheringState === 'new' || t !== 0 && o.usingBundle || (e.iceGatherer.getLocalCandidates().forEach(function(e) { e.component = 1, i += 'a=' + O.writeCandidate(e) + '\r\n' }), e.iceGatherer.state === 'completed' && (i += 'a=end-of-candidates\r\n')) }); var a = new k.RTCSessionDescription({ type: 'offer', sdp: i }); return new Promise(function(e) { if (t.length > 0 && typeof t[0] === 'function') return t[0].apply(null, [a]), void e(); e(a) }) }, e.prototype.createAnswer = function() { var t = arguments; var n = O.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++); this.usingBundle && (n += 'a=group:BUNDLE ' + this.transceivers.map(function(e) { return e.mid }).join(' ') + '\r\n'); var i = O.splitSections(this.remoteDescription.sdp).length - 1; this.transceivers.forEach(function(e, t) { var r; i < t + 1 || (e.isDatachannel ? n += 'm=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:' + e.mid + '\r\n' : (e.stream && (e.kind === 'audio' ? r = e.stream.getAudioTracks()[0] : e.kind === 'video' && (r = e.stream.getVideoTracks()[0]), r && x >= 15019 && e.kind === 'video' && (e.sendEncodingParameters[0].rtx = { ssrc: 1001 * (2 * t + 2) + 1 })), !(t = l(e.localCapabilities, e.remoteCapabilities)).codecs.filter(function(e) { return e.name.toLowerCase() === 'rtx' }).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, n += s(e, t, 'answer', e.stream), e.rtcpParameters && e.rtcpParameters.reducedSize && (n += 'a=rtcp-rsize\r\n'))) }); var r = new k.RTCSessionDescription({ type: 'answer', sdp: n }); return new Promise(function(e) { if (t.length > 0 && typeof t[0] === 'function') return t[0].apply(null, [r]), void e(); e(r) }) }, e.prototype.addIceCandidate = function(e) { var r, t; if (e && e.candidate !== '') { if (!e.sdpMLineIndex && !e.sdpMid) throw new TypeError('sdpMLineIndex or sdpMid required'); if (this.remoteDescription) { var n = e.sdpMLineIndex; if (e.sdpMid) for (var i = 0; i < this.transceivers.length; i++) if (this.transceivers[i].mid === e.sdpMid) { n = i; break } var a = this.transceivers[n]; if (a) { if (a.isDatachannel) return Promise.resolve(); var o = Object.keys(e.candidate).length > 0 ? O.parseCandidate(e.candidate) : {}; if (o.protocol === 'tcp' && (o.port === 0 || o.port === 9)) return Promise.resolve(); if (o.component && o.component !== 1) return Promise.resolve(); (n === 0 || n > 0 && a.iceTransport !== this.transceivers[0].iceTransport) && a.iceTransport.addRemoteCandidate(o); a = e.candidate.trim(); a.indexOf('a=') === 0 && (a = a.substr(2)), (t = O.splitSections(this.remoteDescription.sdp))[n + 1] += 'a=' + (o.type ? a : 'end-of-candidates') + '\r\n', this.remoteDescription.sdp = t.join('') } else (r = new Error('Can not add ICE candidate')).name = 'OperationError' } else (r = new Error('Can not add ICE candidate without a remote description')).name = 'InvalidStateError' } else for (var s = 0; s < this.transceivers.length && (this.transceivers[s].isDatachannel || (this.transceivers[s].iceTransport.addRemoteCandidate({}), (t = O.splitSections(this.remoteDescription.sdp))[s + 1] += 'a=end-of-candidates\r\n', this.remoteDescription.sdp = t.join(''), !this.usingBundle)); s++);var c = arguments; return new Promise(function(e, t) { r ? (c.length > 2 && typeof c[2] === 'function' && c[2].apply(null, [r]), t(r)) : (c.length > 1 && typeof c[1] === 'function' && c[1].apply(null), e()) }) }, e.prototype.getStats = function() { var r = []; this.transceivers.forEach(function(t) { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function(e) { t[e] && r.push(t[e].getStats()) }) }); var i = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1]; return new Promise(function(t) { var n = new Map(); Promise.all(r).then(function(e) { e.forEach(function(r) { Object.keys(r).forEach(function(e) { var t; r[e].type = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[(t = r[e]).type] || t.type, n.set(e, r[e]) }) }), i && i.apply(null, n), t(n) }) }) }, e } }, { sdp: 2 }], 2: [function(e, t, r) { 'use strict'; var d = { generateIdentifier: function() { return Math.random().toString(36).substr(2, 10) } }; d.localCName = d.generateIdentifier(), d.splitLines = function(e) { return e.trim().split('\n').map(function(e) { return e.trim() }) }, d.splitSections = function(e) { return e.split('\nm=').map(function(e, t) { return (t > 0 ? 'm=' + e : e).trim() + '\r\n' }) }, d.matchPrefix = function(e, t) { return d.splitLines(e).filter(function(e) { return e.indexOf(t) === 0 }) }, d.parseCandidate = function(e) { for (var t, r = { foundation: (t = (e.indexOf('a=candidate:') === 0 ? e.substring(12) : e.substring(10)).split(' '))[0], component: parseInt(t[1], 10), protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], port: parseInt(t[5], 10), type: t[7] }, n = 8; n < t.length; n += 2) switch (t[n]) { case 'raddr':r.relatedAddress = t[n + 1]; break; case 'rport':r.relatedPort = parseInt(t[n + 1], 10); break; case 'tcptype':r.tcpType = t[n + 1]; break; case 'ufrag':r.ufrag = t[n + 1], r.usernameFragment = t[n + 1]; break; default:r[t[n]] = t[n + 1] } return r }, d.writeCandidate = function(e) { var t = []; t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.ip), t.push(e.port); var r = e.type; return t.push('typ'), t.push(r), r !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), e.ufrag && (t.push('ufrag'), t.push(e.ufrag)), 'candidate:' + t.join(' ') }, d.parseIceOptions = function(e) { return e.substr(14).split(' ') }, d.parseRtpMap = function(e) { var t = e.substr(9).split(' '); var e = { payloadType: parseInt(t.shift(), 10) }; var t = t[0].split('/'); return e.name = t[0], e.clockRate = parseInt(t[1], 10), e.numChannels = t.length === 3 ? parseInt(t[2], 10) : 1, e }, d.writeRtpMap = function(e) { var t = e.payloadType; return 'a=rtpmap:' + (t = void 0 !== e.preferredPayloadType ? e.preferredPayloadType : t) + ' ' + e.name + '/' + e.clockRate + (e.numChannels !== 1 ? '/' + e.numChannels : '') + '\r\n' }, d.parseExtmap = function(e) { e = e.substr(9).split(' '); return { id: parseInt(e[0], 10), direction: e[0].indexOf('/') > 0 ? e[0].split('/')[1] : 'sendrecv', uri: e[1] } }, d.writeExtmap = function(e) { return 'a=extmap:' + (e.id || e.preferredId) + (e.direction && e.direction !== 'sendrecv' ? '/' + e.direction : '') + ' ' + e.uri + '\r\n' }, d.parseFmtp = function(e) { for (var t, r = {}, n = e.substr(e.indexOf(' ') + 1).split(';'), i = 0; i < n.length; i++)r[(t = n[i].trim().split('='))[0].trim()] = t[1]; return r }, d.writeFmtp = function(t) { var r; var e = ''; var n = t.payloadType; return void 0 !== t.preferredPayloadType && (n = t.preferredPayloadType), t.parameters && Object.keys(t.parameters).length && (r = [], Object.keys(t.parameters).forEach(function(e) { r.push(e + '=' + t.parameters[e]) }), e += 'a=fmtp:' + n + ' ' + r.join(';') + '\r\n'), e }, d.parseRtcpFb = function(e) { e = e.substr(e.indexOf(' ') + 1).split(' '); return { type: e.shift(), parameter: e.join(' ') } }, d.writeRtcpFb = function(e) { var t = ''; var r = e.payloadType; return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(e) { t += 'a=rtcp-fb:' + r + ' ' + e.type + (e.parameter && e.parameter.length ? ' ' + e.parameter : '') + '\r\n' }), t }, d.parseSsrcMedia = function(e) { var t = e.indexOf(' '); var r = { ssrc: parseInt(e.substr(7, t - 7), 10) }; var n = e.indexOf(':', t); return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r }, d.getMid = function(e) { e = d.matchPrefix(e, 'a=mid:')[0]; if (e) return e.substr(6) }, d.parseFingerprint = function(e) { e = e.substr(14).split(' '); return { algorithm: e[0].toLowerCase(), value: e[1] } }, d.getDtlsParameters = function(e, t) { return { role: 'auto', fingerprints: d.matchPrefix(e + t, 'a=fingerprint:').map(d.parseFingerprint) } }, d.writeDtlsParameters = function(e, t) { var r = 'a=setup:' + t + '\r\n'; return e.fingerprints.forEach(function(e) { r += 'a=fingerprint:' + e.algorithm + ' ' + e.value + '\r\n' }), r }, d.getIceParameters = function(e, t) { e = d.splitLines(e); return { usernameFragment: (e = e.concat(d.splitLines(t))).filter(function(e) { return e.indexOf('a=ice-ufrag:') === 0 })[0].substr(12), password: e.filter(function(e) { return e.indexOf('a=ice-pwd:') === 0 })[0].substr(10) } }, d.writeIceParameters = function(e) { return 'a=ice-ufrag:' + e.usernameFragment + '\r\na=ice-pwd:' + e.password + '\r\n' }, d.parseRtpParameters = function(e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = d.splitLines(e)[0].split(' '), n = 3; n < r.length; n++) { var i = r[n]; var a = d.matchPrefix(e, 'a=rtpmap:' + i + ' ')[0]; if (a) { var o = d.parseRtpMap(a); var a = d.matchPrefix(e, 'a=fmtp:' + i + ' '); switch (o.parameters = a.length ? d.parseFmtp(a[0]) : {}, o.rtcpFeedback = d.matchPrefix(e, 'a=rtcp-fb:' + i + ' ').map(d.parseRtcpFb), t.codecs.push(o), o.name.toUpperCase()) { case 'RED':case 'ULPFEC':t.fecMechanisms.push(o.name.toUpperCase()) } } } return d.matchPrefix(e, 'a=extmap:').forEach(function(e) { t.headerExtensions.push(d.parseExtmap(e)) }), t }, d.writeRtpDescription = function(e, t) { var r = ''; r += 'm=' + e + ' ', r += t.codecs.length > 0 ? '9' : '0', r += ' UDP/TLS/RTP/SAVPF ', r += t.codecs.map(function(e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType }).join(' ') + '\r\n', r += 'c=IN IP4 0.0.0.0\r\n', r += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(function(e) { r += d.writeRtpMap(e), r += d.writeFmtp(e), r += d.writeRtcpFb(e) }); var n = 0; return t.codecs.forEach(function(e) { e.maxptime > n && (n = e.maxptime) }), n > 0 && (r += 'a=maxptime:' + n + '\r\n'), r += 'a=rtcp-mux\r\n', t.headerExtensions.forEach(function(e) { r += d.writeExtmap(e) }), r }, d.parseRtpEncodingParameters = function(e) { var t; var r = []; var n = d.parseRtpParameters(e); var i = n.fecMechanisms.indexOf('RED') !== -1; var a = n.fecMechanisms.indexOf('ULPFEC') !== -1; var o = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'cname' }); var s = o.length > 0 && o[0].ssrc; var o = d.matchPrefix(e, 'a=ssrc-group:FID').map(function(e) { e = e.split(' '); return e.shift(), e.map(function(e) { return parseInt(e, 10) }) }); o.length > 0 && o[0].length > 1 && o[0][0] === s && (t = o[0][1]), n.codecs.forEach(function(e) { e.name.toUpperCase() === 'RTX' && e.parameters.apt && (e = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10), rtx: { ssrc: t } }, r.push(e), i && ((e = JSON.parse(JSON.stringify(e))).fec = { ssrc: t, mechanism: a ? 'red+ulpfec' : 'red' }, r.push(e))) }), r.length === 0 && s && r.push({ ssrc: s }); var c = d.matchPrefix(e, 'b='); return c.length && (c = c[0].indexOf('b=TIAS:') === 0 ? parseInt(c[0].substr(7), 10) : c[0].indexOf('b=AS:') === 0 ? 1e3 * parseInt(c[0].substr(5), 10) * 0.95 - 16e3 : void 0, r.forEach(function(e) { e.maxBitrate = c })), r }, d.parseRtcpParameters = function(e) { var t = {}; var r = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'cname' })[0]; r && (t.cname = r.value, t.ssrc = r.ssrc); r = d.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = r.length > 0, t.compound = r.length === 0; e = d.matchPrefix(e, 'a=rtcp-mux'); return t.mux = e.length > 0, t }, d.parseMsid = function(e) { var t; var r = d.matchPrefix(e, 'a=msid:'); if (r.length === 1) return { stream: (t = r[0].substr(7).split(' '))[0], track: t[1] }; e = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'msid' }); return e.length > 0 ? { stream: (t = e[0].value.split(' '))[0], track: t[1] } : void 0 }, d.generateSessionId = function() { return Math.random().toString().substr(2, 21) }, d.writeSessionBoilerplate = function(e, t) { t = void 0 !== t ? t : 2; return 'v=0\r\no=thisisadapterortc ' + (e || d.generateSessionId()) + ' ' + t + ' IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n' }, d.writeMediaSection = function(e, t, r, n) { t = d.writeRtpDescription(e.kind, t); return t += d.writeIceParameters(e.iceGatherer.getLocalParameters()), t += d.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === 'offer' ? 'actpass' : 'active'), t += 'a=mid:' + e.mid + '\r\n', e.direction ? t += 'a=' + e.direction + '\r\n' : e.rtpSender && e.rtpReceiver ? t += 'a=sendrecv\r\n' : e.rtpSender ? t += 'a=sendonly\r\n' : e.rtpReceiver ? t += 'a=recvonly\r\n' : t += 'a=inactive\r\n', e.rtpSender && (t += 'a=' + (n = 'msid:' + n.id + ' ' + e.rtpSender.track.id + '\r\n'), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + n, e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + n, t += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n')), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + d.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + d.localCName + '\r\n'), t }, d.getDirection = function(e, t) { for (var r = d.splitLines(e), n = 0; n < r.length; n++) switch (r[n]) { case 'a=sendrecv':case 'a=sendonly':case 'a=recvonly':case 'a=inactive':return r[n].substr(2) } return t ? d.getDirection(t) : 'sendrecv' }, d.getKind = function(e) { return d.splitLines(e)[0].split(' ')[0].substr(2) }, d.isRejected = function(e) { return e.split(' ', 2)[1] === '0' }, t.exports = d }, {}], 3: [function(r, n, e) { (function(e) { 'use strict'; var t = r('./adapter_factory.js'); n.exports = t({ window: e.window }) }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, { './adapter_factory.js': 4 }], 4: [function(f, e, t) { 'use strict'; e.exports = function(e, t) { var r; var n = e && e.window; var i = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }; for (r in t)hasOwnProperty.call(t, r) && (i[r] = t[r]); var a = f('./utils'); var o = a.log; var e = a.detectBrowser(n); var s = { browserDetails: e, extractVersion: a.extractVersion, disableLog: a.disableLog, disableWarnings: a.disableWarnings }; var c = f('./chrome/chrome_shim') || null; var d = f('./edge/edge_shim') || null; var p = f('./firefox/firefox_shim') || null; var u = f('./safari/safari_shim') || null; var l = f('./common_shim') || null; switch (e.browser) { case 'chrome':if (!c || !c.shimPeerConnection || !i.shimChrome) return o('Chrome shim is not included in this adapter release.'), s; o('adapter.js shimming chrome.'), (s.browserShim = c).shimGetUserMedia(n), c.shimMediaStream(n), a.shimCreateObjectURL(n), c.shimSourceObject(n), c.shimPeerConnection(n), c.shimOnTrack(n), c.shimAddTrackRemoveTrack(n), c.shimGetSendersWithDtmf(n), l.shimRTCIceCandidate(n); break; case 'firefox':if (!p || !p.shimPeerConnection || !i.shimFirefox) return o('Firefox shim is not included in this adapter release.'), s; o('adapter.js shimming firefox.'), (s.browserShim = p).shimGetUserMedia(n), a.shimCreateObjectURL(n), p.shimSourceObject(n), p.shimPeerConnection(n), p.shimOnTrack(n), l.shimRTCIceCandidate(n); break; case 'edge':if (!d || !d.shimPeerConnection || !i.shimEdge) return o('MS edge shim is not included in this adapter release.'), s; o('adapter.js shimming edge.'), (s.browserShim = d).shimGetUserMedia(n), a.shimCreateObjectURL(n), d.shimPeerConnection(n), d.shimReplaceTrack(n); break; case 'safari':if (!u || !i.shimSafari) return o('Safari shim is not included in this adapter release.'), s; o('adapter.js shimming safari.'), s.browserShim = u, a.shimCreateObjectURL(n), u.shimRTCIceServerUrls(n), u.shimCallbacksAPI(n), u.shimLocalStreamsAPI(n), u.shimRemoteStreamsAPI(n), u.shimTrackEventTransceiver(n), u.shimGetUserMedia(n), l.shimRTCIceCandidate(n); break; default:o('Unsupported browser!') } return s } }, { './chrome/chrome_shim': 5, './common_shim': 7, './edge/edge_shim': 8, './firefox/firefox_shim': 10, './safari/safari_shim': 12, './utils': 13 }], 5: [function(e, t, r) { 'use strict'; var o = e('../utils.js'); var n = o.log; var i = { shimMediaStream: function(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream }, shimOnTrack: function(a) { var e; typeof a !== 'object' || !a.RTCPeerConnection || 'ontrack' in a.RTCPeerConnection.prototype || (Object.defineProperty(a.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack }, set: function(e) { this._ontrack && this.removeEventListener('track', this._ontrack), this.addEventListener('track', this._ontrack = e) } }), e = a.RTCPeerConnection.prototype.setRemoteDescription, a.RTCPeerConnection.prototype.setRemoteDescription = function() { var i = this; return i._ontrackpoly || (i._ontrackpoly = function(n) { n.stream.addEventListener('addtrack', function(t) { var e = a.RTCPeerConnection.prototype.getReceivers ? i.getReceivers().find(function(e) { return e.track && e.track.id === t.track.id }) : { track: t.track }; var r = new Event('track'); r.track = t.track, r.receiver = e, r.transceiver = { receiver: e }, r.streams = [n.stream], i.dispatchEvent(r) }), n.stream.getTracks().forEach(function(t) { var e = a.RTCPeerConnection.prototype.getReceivers ? i.getReceivers().find(function(e) { return e.track && e.track.id === t.id }) : { track: t }; var r = new Event('track'); r.track = t, r.receiver = e, r.transceiver = { receiver: e }, r.streams = [n.stream], i.dispatchEvent(r) }) }, i.addEventListener('addstream', i._ontrackpoly)), e.apply(i, arguments) }) }, shimGetSendersWithDtmf: function(e) { var n, i, t, r, a, o; typeof e === 'object' && e.RTCPeerConnection && !('getSenders' in e.RTCPeerConnection.prototype) && 'createDTMFSender' in e.RTCPeerConnection.prototype ? (n = function(e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && (t.kind === 'audio' ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }, e.RTCPeerConnection.prototype.getSenders || (e.RTCPeerConnection.prototype.getSenders = function() { return this._senders = this._senders || [], this._senders.slice() }, i = e.RTCPeerConnection.prototype.addTrack, e.RTCPeerConnection.prototype.addTrack = function(e, t) { var r = i.apply(this, arguments); return r || (r = n(this, e), this._senders.push(r)), r }, t = e.RTCPeerConnection.prototype.removeTrack, e.RTCPeerConnection.prototype.removeTrack = function(e) { t.apply(this, arguments); e = this._senders.indexOf(e); e !== -1 && this._senders.splice(e, 1) }), r = e.RTCPeerConnection.prototype.addStream, e.RTCPeerConnection.prototype.addStream = function(e) { var t = this; t._senders = t._senders || [], r.apply(t, [e]), e.getTracks().forEach(function(e) { t._senders.push(n(t, e)) }) }, a = e.RTCPeerConnection.prototype.removeStream, e.RTCPeerConnection.prototype.removeStream = function(e) { var r = this; r._senders = r._senders || [], a.apply(r, [r._streams[e.id] || e]), e.getTracks().forEach(function(t) { var e = r._senders.find(function(e) { return e.track === t }); e && r._senders.splice(r._senders.indexOf(e), 1) }) }) : typeof e === 'object' && e.RTCPeerConnection && 'getSenders' in e.RTCPeerConnection.prototype && 'createDTMFSender' in e.RTCPeerConnection.prototype && e.RTCRtpSender && !('dtmf' in e.RTCRtpSender.prototype) && (o = e.RTCPeerConnection.prototype.getSenders, e.RTCPeerConnection.prototype.getSenders = function() { var t = this; var e = o.apply(t, []); return e.forEach(function(e) { e._pc = t }), e }, Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } })) }, shimSourceObject: function(e) { var r = e && e.URL; typeof e === 'object' && (!e.HTMLMediaElement || 'srcObject' in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject }, set: function(e) { var t = this; this._srcObject = e, this.src && r.revokeObjectURL(this.src), e ? (this.src = r.createObjectURL(e), e.addEventListener('addtrack', function() { t.src && r.revokeObjectURL(t.src), t.src = r.createObjectURL(e) }), e.addEventListener('removetrack', function() { t.src && r.revokeObjectURL(t.src), t.src = r.createObjectURL(e) })) : this.src = '' } })) }, shimAddTrackRemoveTrack: function(i) { function a(r, e) { var n = e.sdp; return Object.keys(r._reverseStreams || []).forEach(function(e) { var t = r._reverseStreams[e]; var e = r._streams[t.id]; n = n.replace(new RegExp(e.id, 'g'), t.id) }), new RTCSessionDescription({ type: e.type, sdp: n }) } var r, n, o, t, s; i.RTCPeerConnection.prototype.addTrack || (r = i.RTCPeerConnection.prototype.getLocalStreams, i.RTCPeerConnection.prototype.getLocalStreams = function() { var t = this; var e = r.apply(this); return t._reverseStreams = t._reverseStreams || {}, e.map(function(e) { return t._reverseStreams[e.id] }) }, n = i.RTCPeerConnection.prototype.addStream, i.RTCPeerConnection.prototype.addStream = function(e) { var t; var r = this; r._streams = r._streams || {}, r._reverseStreams = r._reverseStreams || {}, e.getTracks().forEach(function(t) { if (r.getSenders().find(function(e) { return e.track === t })) throw new DOMException('Track already exists.', 'InvalidAccessError') }), r._reverseStreams[e.id] || (t = new i.MediaStream(e.getTracks()), r._streams[e.id] = t, r._reverseStreams[t.id] = e, e = t), n.apply(r, [e]) }, o = i.RTCPeerConnection.prototype.removeStream, i.RTCPeerConnection.prototype.removeStream = function(e) { var t = this; t._streams = t._streams || {}, t._reverseStreams = t._reverseStreams || {}, o.apply(t, [t._streams[e.id] || e]), delete t._reverseStreams[(t._streams[e.id] || e).id], delete t._streams[e.id] }, i.RTCPeerConnection.prototype.addTrack = function(t, e) { var r = this; if (r.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); var n = [].slice.call(arguments, 1); if (n.length !== 1 || !n[0].getTracks().find(function(e) { return e === t })) throw new DOMException('The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.', 'NotSupportedError'); if (r.getSenders().find(function(e) { return e.track === t })) throw new DOMException('Track already exists.', 'InvalidAccessError'); r._streams = r._streams || {}, r._reverseStreams = r._reverseStreams || {}; n = r._streams[e.id]; return n ? (n.addTrack(t), Promise.resolve().then(function() { r.dispatchEvent(new Event('negotiationneeded')) })) : (n = new i.MediaStream([t]), r._streams[e.id] = n, r._reverseStreams[n.id] = e, r.addStream(n)), r.getSenders().find(function(e) { return e.track === t }) }, ['createOffer', 'createAnswer'].forEach(function(e) { var n = i.RTCPeerConnection.prototype[e]; i.RTCPeerConnection.prototype[e] = function() { var t = this; var r = arguments; return arguments.length && typeof arguments[0] === 'function' ? n.apply(t, [function(e) { e = a(t, e); r[0].apply(null, [e]) }, function(e) { r[1] && r[1].apply(null, e) }, arguments[2]]) : n.apply(t, arguments).then(function(e) { return a(t, e) }) } }), t = i.RTCPeerConnection.prototype.setLocalDescription, i.RTCPeerConnection.prototype.setLocalDescription = function() { var r, e, n; return arguments.length && arguments[0].type && (arguments[0] = (r = this, n = (e = arguments[0]).sdp, Object.keys(r._reverseStreams || []).forEach(function(e) { var t = r._reverseStreams[e]; var e = r._streams[t.id]; n = n.replace(new RegExp(t.id, 'g'), e.id) }), new RTCSessionDescription({ type: e.type, sdp: n }))), t.apply(this, arguments) }, s = Object.getOwnPropertyDescriptor(i.RTCPeerConnection.prototype, 'localDescription'), Object.defineProperty(i.RTCPeerConnection.prototype, 'localDescription', { get: function() { var e = s.get.apply(this); return e.type === '' ? e : a(this, e) } }), i.RTCPeerConnection.prototype.removeTrack = function(t) { var r; var n = this; if (n.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); if (!t._pc) throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.', 'TypeError'); if (t._pc !== n) throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError'); n._streams = n._streams || {}, Object.keys(n._streams).forEach(function(e) { n._streams[e].getTracks().find(function(e) { return t.track === e }) && (r = n._streams[e]) }), r && (r.getTracks().length === 1 ? n.removeStream(r) : r.removeTrack(t.track), n.dispatchEvent(new Event('negotiationneeded'))) }) }, shimPeerConnection: function(r) { var a; var e = o.detectBrowser(r); r.RTCPeerConnection ? (a = r.RTCPeerConnection, r.RTCPeerConnection = function(e, t) { if (e && e.iceServers) { for (var r = [], n = 0; n < e.iceServers.length; n++) { var i = e.iceServers[n]; !i.hasOwnProperty('urls') && i.hasOwnProperty('url') ? (o.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (i = JSON.parse(JSON.stringify(i))).urls = i.url, r.push(i)) : r.push(e.iceServers[n]) }e.iceServers = r } return new a(e, t) }, r.RTCPeerConnection.prototype = a.prototype, Object.defineProperty(r.RTCPeerConnection, 'generateCertificate', { get: function() { return a.generateCertificate } })) : (r.RTCPeerConnection = function(e, t) { return n('PeerConnection'), e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy), new r.webkitRTCPeerConnection(e, t) }, r.RTCPeerConnection.prototype = r.webkitRTCPeerConnection.prototype, r.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(r.RTCPeerConnection, 'generateCertificate', { get: function() { return r.webkitRTCPeerConnection.generateCertificate } })); var s = r.RTCPeerConnection.prototype.getStats; r.RTCPeerConnection.prototype.getStats = function(e, t, r) { var n = this; var i = arguments; if (arguments.length > 0 && typeof e === 'function') return s.apply(this, arguments); if (s.length === 0 && (arguments.length === 0 || typeof e !== 'function')) return s.apply(this, []); function a(e) { var n = {}; return e.result().forEach(function(t) { var r = { id: t.id, timestamp: t.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[t.type] || t.type }; t.names().forEach(function(e) { r[e] = t.stat(e) }), n[r.id] = r }), n } function o(t) { return new Map(Object.keys(t).map(function(e) { return [e, t[e]] })) } return arguments.length >= 2 ? s.apply(this, [function(e) { i[1](o(a(e))) }, e]) : new Promise(function(t, e) { s.apply(n, [function(e) { t(o(a(e))) }, e]) }).then(t, r) }, e.version < 51 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var i = r.RTCPeerConnection.prototype[e]; r.RTCPeerConnection.prototype[e] = function() { var r = arguments; var n = this; var e = new Promise(function(e, t) { i.apply(n, [r[0], e, t]) }); return r.length < 2 ? e : e.then(function() { r[1].apply(null, []) }, function(e) { r.length >= 3 && r[2].apply(null, [e]) }) } }), e.version < 52 && ['createOffer', 'createAnswer'].forEach(function(e) { var i = r.RTCPeerConnection.prototype[e]; r.RTCPeerConnection.prototype[e] = function() { var r = this; if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') { var n = arguments.length === 1 ? arguments[0] : void 0; return new Promise(function(e, t) { i.apply(r, [e, t, n]) }) } return i.apply(this, arguments) } }), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var t = r.RTCPeerConnection.prototype[e]; r.RTCPeerConnection.prototype[e] = function() { return arguments[0] = new (e === 'addIceCandidate' ? r.RTCIceCandidate : r.RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }); var t = r.RTCPeerConnection.prototype.addIceCandidate; r.RTCPeerConnection.prototype.addIceCandidate = function() { return arguments[0] ? t.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) } } }; t.exports = { shimMediaStream: i.shimMediaStream, shimOnTrack: i.shimOnTrack, shimAddTrackRemoveTrack: i.shimAddTrackRemoveTrack, shimGetSendersWithDtmf: i.shimGetSendersWithDtmf, shimSourceObject: i.shimSourceObject, shimPeerConnection: i.shimPeerConnection, shimGetUserMedia: e('./getusermedia') } }, { '../utils.js': 13, './getusermedia': 6 }], 6: [function(e, t, r) { 'use strict'; var c = e('../utils.js'); var d = c.log; t.exports = function(e) { function o(i) { if (typeof i !== 'object' || i.mandatory || i.optional) return i; var a = {}; return Object.keys(i).forEach(function(t) { var r, n, e; t !== 'require' && t !== 'advanced' && t !== 'mediaSource' && (void 0 !== (r = typeof i[t] === 'object' ? i[t] : { ideal: i[t] }).exact && typeof r.exact === 'number' && (r.min = r.max = r.exact), n = function(e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t }, void 0 !== r.ideal && (a.optional = a.optional || [], e = {}, typeof r.ideal === 'number' ? (e[n('min', t)] = r.ideal, a.optional.push(e), (e = {})[n('max', t)] = r.ideal) : e[n('', t)] = r.ideal, a.optional.push(e)), void 0 !== r.exact && typeof r.exact !== 'number' ? (a.mandatory = a.mandatory || {}, a.mandatory[n('', t)] = r.exact) : ['min', 'max'].forEach(function(e) { void 0 !== r[e] && (a.mandatory = a.mandatory || {}, a.mandatory[n(e, t)] = r[e]) })) }), i.advanced && (a.optional = (a.optional || []).concat(i.advanced)), a } function n(r, n) { if ((r = JSON.parse(JSON.stringify(r))) && typeof r.audio === 'object' && ((e = function(e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) })((r = JSON.parse(JSON.stringify(r))).audio, 'autoGainControl', 'googAutoGainControl'), e(r.audio, 'noiseSuppression', 'googNoiseSuppression'), r.audio = o(r.audio)), r && typeof r.video === 'object') { var i; var a = (a = r.video.facingMode) && (typeof a === 'object' ? a : { ideal: a }); var e = t.version < 61; if (a && (a.exact === 'user' || a.exact === 'environment' || a.ideal === 'user' || a.ideal === 'environment') && (!s.mediaDevices.getSupportedConstraints || !s.mediaDevices.getSupportedConstraints().facingMode || e)) if (delete r.video.facingMode, a.exact === 'environment' || a.ideal === 'environment' ? i = ['back', 'rear'] : a.exact !== 'user' && a.ideal !== 'user' || (i = ['front']), i) return s.mediaDevices.enumerateDevices().then(function(e) { var t = (e = e.filter(function(e) { return e.kind === 'videoinput' })).find(function(t) { return i.some(function(e) { return t.label.toLowerCase().indexOf(e) !== -1 }) }); return (t = !t && e.length && i.indexOf('back') !== -1 ? e[e.length - 1] : t) && (r.video.deviceId = a.exact ? { exact: t.deviceId } : { ideal: t.deviceId }), r.video = o(r.video), d('chrome: ' + JSON.stringify(r)), n(r) }); r.video = o(r.video) } return d('chrome: ' + JSON.stringify(r)), n(r) } function i(e) { return { name: { PermissionDeniedError: 'NotAllowedError', InvalidStateError: 'NotReadableError', DevicesNotFoundError: 'NotFoundError', ConstraintNotSatisfiedError: 'OverconstrainedError', TrackStartError: 'NotReadableError', MediaDeviceFailedDueToShutdown: 'NotReadableError', MediaDeviceKillSwitchOn: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message && ': ') + this.message } } } var t = c.detectBrowser(e); var s = e && e.navigator; s.getUserMedia = function(e, t, r) { n(e, function(e) { s.webkitGetUserMedia(e, t, function(e) { r && r(i(e)) }) }) }; function r(r) { return new Promise(function(e, t) { s.getUserMedia(r, e, t) }) } var a; s.mediaDevices || (s.mediaDevices = { getUserMedia: r, enumerateDevices: function() { return new Promise(function(t) { var r = { audio: 'audioinput', video: 'videoinput' }; return e.MediaStreamTrack.getSources(function(e) { t(e.map(function(e) { return { label: e.label, kind: r[e.kind], deviceId: e.id, groupId: '' } })) }) }) }, getSupportedConstraints: function() { return { deviceId: !0, echoCancellation: !0, facingMode: !0, frameRate: !0, height: !0, width: !0 } } }), s.mediaDevices.getUserMedia ? (a = s.mediaDevices.getUserMedia.bind(s.mediaDevices), s.mediaDevices.getUserMedia = function(e) { return n(e, function(t) { return a(t).then(function(e) { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) { e.stop() }), new DOMException('', 'NotFoundError'); return e }, function(e) { return Promise.reject(i(e)) }) }) }) : s.mediaDevices.getUserMedia = r, void 0 === s.mediaDevices.addEventListener && (s.mediaDevices.addEventListener = function() { d('Dummy mediaDevices.addEventListener called.') }), void 0 === s.mediaDevices.removeEventListener && (s.mediaDevices.removeEventListener = function() { d('Dummy mediaDevices.removeEventListener called.') }) } }, { '../utils.js': 13 }], 7: [function(e, t, r) { 'use strict'; function i(e, n, i) { var a, o; e.RTCPeerConnection && (e = e.RTCPeerConnection.prototype, a = e.addEventListener, e.addEventListener = function(e, t) { if (e !== n) return a.apply(this, arguments); function r(e) { t(i(e)) } return this._eventMap = this._eventMap || {}, this._eventMap[t] = r, a.apply(this, [e, r]) }, o = e.removeEventListener, e.removeEventListener = function(e, t) { if (e !== n || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments); var r = this._eventMap[t]; return delete this._eventMap[t], o.apply(this, [e, r]) }, Object.defineProperty(e, 'on' + n, { get: function() { return this['_on' + n] }, set: function(e) { this['_on' + n] && (this.removeEventListener(n, this['_on' + n]), delete this['_on' + n]), e && this.addEventListener(n, this['_on' + n] = e) } })) } var a = e('sdp'); t.exports = { shimRTCIceCandidate: function(t) { var n; t.RTCIceCandidate && 'foundation' in t.RTCIceCandidate.prototype || (n = t.RTCIceCandidate, t.RTCIceCandidate = function(e) { typeof e === 'object' && e.candidate && e.candidate.indexOf('a=') === 0 && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)); var t = new n(e); var e = a.parseCandidate(e.candidate); var r = Object.assign(t, e); return r.toJSON = function() { return { candidate: r.candidate, sdpMid: r.sdpMid, sdpMLineIndex: r.sdpMLineIndex, usernameFragment: r.usernameFragment } }, r }, i(t, 'icecandidate', function(e) { return e.candidate && Object.defineProperty(e, 'candidate', { value: new t.RTCIceCandidate(e.candidate), writable: 'false' }), e })) } } }, { sdp: 2 }], 8: [function(e, t, r) { 'use strict'; var n = e('../utils'); var i = e('rtcpeerconnection-shim'); t.exports = { shimGetUserMedia: e('./getusermedia'), shimPeerConnection: function(e) { var r; var t = n.detectBrowser(e); e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function(e) { return e }), e.RTCSessionDescription || (e.RTCSessionDescription = function(e) { return e }), t.version < 15025) && (r = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, 'enabled'), Object.defineProperty(e.MediaStreamTrack.prototype, 'enabled', { set: function(e) { r.set.call(this, e); var t = new Event('enabled'); t.enabled = e, this.dispatchEvent(t) } })), !e.RTCRtpSender || 'dtmf' in e.RTCRtpSender.prototype || Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === 'video' && (this._dtmf = null)), this._dtmf } }), e.RTCPeerConnection = i(e, t.version) }, shimReplaceTrack: function(e) { !e.RTCRtpSender || 'replaceTrack' in e.RTCRtpSender.prototype || (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } } }, { '../utils': 13, './getusermedia': 9, 'rtcpeerconnection-shim': 1 }], 9: [function(e, t, r) { 'use strict'; t.exports = function(e) { var e = e && e.navigator; var t = e.mediaDevices.getUserMedia.bind(e.mediaDevices); e.mediaDevices.getUserMedia = function(e) { return t(e).catch(function(e) { return Promise.reject({ name: { PermissionDeniedError: 'NotAllowedError' }[(e = e).name] || e.name, message: e.message, constraint: e.constraint, toString: function() { return this.name } }) }) } } }, {}], 10: [function(e, t, r) { 'use strict'; var n = e('../utils'); var i = { shimOnTrack: function(e) { typeof e !== 'object' || !e.RTCPeerConnection || 'ontrack' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack }, set: function(e) { this._ontrack && (this.removeEventListener('track', this._ontrack), this.removeEventListener('addstream', this._ontrackpoly)), this.addEventListener('track', this._ontrack = e), this.addEventListener('addstream', this._ontrackpoly = function(r) { r.stream.getTracks().forEach(function(e) { var t = new Event('track'); t.track = e, t.receiver = { track: e }, t.transceiver = { receiver: t.receiver }, t.streams = [r.stream], this.dispatchEvent(t) }.bind(this)) }.bind(this)) } }), typeof e === 'object' && e.RTCPeerConnection && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function() { return { receiver: this.receiver } } }) }, shimSourceObject: function(e) { typeof e === 'object' && (!e.HTMLMediaElement || 'srcObject' in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject }, set: function(e) { this.mozSrcObject = e } })) }, shimPeerConnection: function(s) { var e; var a; var r; var c = n.detectBrowser(s); typeof s === 'object' && (s.RTCPeerConnection || s.mozRTCPeerConnection) && (s.RTCPeerConnection || (s.RTCPeerConnection = function(e, t) { if (c.version < 38 && e && e.iceServers) { for (var r = [], n = 0; n < e.iceServers.length; n++) { var i = e.iceServers[n]; if (i.hasOwnProperty('urls')) for (var a = 0; a < i.urls.length; a++) { var o = { url: i.urls[a] }; i.urls[a].indexOf('turn') === 0 && (o.username = i.username, o.credential = i.credential), r.push(o) } else r.push(e.iceServers[n]) }e.iceServers = r } return new s.mozRTCPeerConnection(e, t) }, s.RTCPeerConnection.prototype = s.mozRTCPeerConnection.prototype, s.mozRTCPeerConnection.generateCertificate && Object.defineProperty(s.RTCPeerConnection, 'generateCertificate', { get: function() { return s.mozRTCPeerConnection.generateCertificate } }), s.RTCSessionDescription = s.mozRTCSessionDescription, s.RTCIceCandidate = s.mozRTCIceCandidate), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var t = s.RTCPeerConnection.prototype[e]; s.RTCPeerConnection.prototype[e] = function() { return arguments[0] = new (e === 'addIceCandidate' ? s.RTCIceCandidate : s.RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }), e = s.RTCPeerConnection.prototype.addIceCandidate, s.RTCPeerConnection.prototype.addIceCandidate = function() { return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }, a = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }, r = s.RTCPeerConnection.prototype.getStats, s.RTCPeerConnection.prototype.getStats = function(e, i, t) { return r.apply(this, [e || null]).then(function(r) { if (c.version < 48 && (t = r, n = new Map(), Object.keys(t).forEach(function(e) { n.set(e, t[e]), n[e] = t[e] }), r = n), c.version < 53 && !i) try { r.forEach(function(e) { e.type = a[e.type] || e.type }) } catch (e) { if (e.name !== 'TypeError') throw e; r.forEach(function(e, t) { r.set(t, Object.assign({}, e, { type: a[e.type] || e.type })) }) } var t, n; return r }).then(i, t) }) } }; t.exports = { shimOnTrack: i.shimOnTrack, shimSourceObject: i.shimSourceObject, shimPeerConnection: i.shimPeerConnection, shimGetUserMedia: e('./getusermedia') } }, { '../utils': 13, './getusermedia': 11 }], 11: [function(e, t, r) { 'use strict'; var u = e('../utils'); var l = u.log; t.exports = function(e) { function i(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message && ': ') + this.message } } } function n(e, t, r) { function n(n) { if (typeof n !== 'object' || n.require) return n; var i = []; return Object.keys(n).forEach(function(e) { var t, r; e !== 'require' && e !== 'advanced' && e !== 'mediaSource' && (void 0 === (t = n[e] = typeof n[e] === 'object' ? n[e] : { ideal: n[e] }).min && void 0 === t.max && void 0 === t.exact || i.push(e), void 0 !== t.exact && (typeof t.exact === 'number' ? t.min = t.max = t.exact : n[e] = t.exact, delete t.exact), void 0 !== t.ideal && (n.advanced = n.advanced || [], r = {}, typeof t.ideal === 'number' ? r[e] = { min: t.ideal, max: t.ideal } : r[e] = t.ideal, n.advanced.push(r), delete t.ideal, Object.keys(t).length || delete n[e])) }), i.length && (n.require = i), n } return e = JSON.parse(JSON.stringify(e)), d.version < 38 && (l('spec: ' + JSON.stringify(e)), e.audio && (e.audio = n(e.audio)), e.video && (e.video = n(e.video)), l('ff37: ' + JSON.stringify(e))), p.mozGetUserMedia(e, t, function(e) { r(i(e)) }) } var t; var r; var a; var o; var s; var c; var d = u.detectBrowser(e); var p = e && e.navigator; var e = e && e.MediaStreamTrack; p.mediaDevices || (p.mediaDevices = { getUserMedia: function(r) { return new Promise(function(e, t) { n(r, e, t) }) }, addEventListener: function() {}, removeEventListener: function() {} }), p.mediaDevices.enumerateDevices = p.mediaDevices.enumerateDevices || function() { return new Promise(function(e) { e([{ kind: 'audioinput', deviceId: 'default', label: '', groupId: '' }, { kind: 'videoinput', deviceId: 'default', label: '', groupId: '' }]) }) }, d.version < 41 && (t = p.mediaDevices.enumerateDevices.bind(p.mediaDevices), p.mediaDevices.enumerateDevices = function() { return t().then(void 0, function(e) { if (e.name === 'NotFoundError') return []; throw e }) }), d.version < 49 && (r = p.mediaDevices.getUserMedia.bind(p.mediaDevices), p.mediaDevices.getUserMedia = function(t) { return r(t).then(function(e) { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) { e.stop() }), new DOMException('The object can not be found here.', 'NotFoundError'); return e }, function(e) { return Promise.reject(i(e)) }) }), d.version > 55 && 'autoGainControl' in p.mediaDevices.getSupportedConstraints() || (a = function(e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }, o = p.mediaDevices.getUserMedia.bind(p.mediaDevices), p.mediaDevices.getUserMedia = function(e) { return typeof e === 'object' && typeof e.audio === 'object' && (e = JSON.parse(JSON.stringify(e)), a(e.audio, 'autoGainControl', 'mozAutoGainControl'), a(e.audio, 'noiseSuppression', 'mozNoiseSuppression')), o(e) }, e && e.prototype.getSettings && (s = e.prototype.getSettings, e.prototype.getSettings = function() { var e = s.apply(this, arguments); return a(e, 'mozAutoGainControl', 'autoGainControl'), a(e, 'mozNoiseSuppression', 'noiseSuppression'), e }), e && e.prototype.applyConstraints && (c = e.prototype.applyConstraints, e.prototype.applyConstraints = function(e) { return this.kind === 'audio' && typeof e === 'object' && (e = JSON.parse(JSON.stringify(e)), a(e, 'autoGainControl', 'mozAutoGainControl'), a(e, 'noiseSuppression', 'mozNoiseSuppression')), c.apply(this, [e]) })), p.getUserMedia = function(e, t, r) { if (d.version < 44) return n(e, t, r); u.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia'), p.mediaDevices.getUserMedia(e).then(t, r) } } }, { '../utils': 13 }], 12: [function(e, t, r) { 'use strict'; var o = e('../utils'); var e = { shimLocalStreamsAPI: function(e) { var n; typeof e === 'object' && e.RTCPeerConnection && ('getLocalStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() { return this._localStreams || (this._localStreams = []), this._localStreams }), 'getStreamById' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getStreamById = function(t) { var r = null; return this._localStreams && this._localStreams.forEach(function(e) { e.id === t && (r = e) }), this._remoteStreams && this._remoteStreams.forEach(function(e) { e.id === t && (r = e) }), r }), 'addStream' in e.RTCPeerConnection.prototype || (n = e.RTCPeerConnection.prototype.addTrack, e.RTCPeerConnection.prototype.addStream = function(t) { this._localStreams || (this._localStreams = []), this._localStreams.indexOf(t) === -1 && this._localStreams.push(t); var r = this; t.getTracks().forEach(function(e) { n.call(r, e, t) }) }, e.RTCPeerConnection.prototype.addTrack = function(e, t) { t && (this._localStreams ? this._localStreams.indexOf(t) === -1 && this._localStreams.push(t) : this._localStreams = [t]), n.call(this, e, t) }), 'removeStream' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) { this._localStreams || (this._localStreams = []); var t; var r; var n = this._localStreams.indexOf(e); n !== -1 && (this._localStreams.splice(n, 1), t = this, r = e.getTracks(), this.getSenders().forEach(function(e) { r.indexOf(e.track) !== -1 && t.removeTrack(e) })) })) }, shimRemoteStreamsAPI: function(e) { typeof e === 'object' && e.RTCPeerConnection && ('getRemoteStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() { return this._remoteStreams || [] }), 'onaddstream' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream }, set: function(e) { this._onaddstream && (this.removeEventListener('addstream', this._onaddstream), this.removeEventListener('track', this._onaddstreampoly)), this.addEventListener('addstream', this._onaddstream = e), this.addEventListener('track', this._onaddstreampoly = function(e) { var t = e.streams[0]; this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.indexOf(t) >= 0 || (this._remoteStreams.push(t), (t = new Event('addstream')).stream = e.streams[0], this.dispatchEvent(t)) }.bind(this)) } })) }, shimCallbacksAPI: function(e) { var t, n, i, a, o, s; typeof e === 'object' && e.RTCPeerConnection && (t = e.RTCPeerConnection.prototype, n = t.createOffer, i = t.createAnswer, a = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate, t.createOffer = function(e, t) { var r = arguments.length >= 2 ? arguments[2] : e; var r = n.apply(this, [r]); return t ? (r.then(e, t), Promise.resolve()) : r }, t.createAnswer = function(e, t) { var r = arguments.length >= 2 ? arguments[2] : e; var r = i.apply(this, [r]); return t ? (r.then(e, t), Promise.resolve()) : r }, e = function(e, t, r) { e = a.apply(this, [e]); return r ? (e.then(t, r), Promise.resolve()) : e }, t.setLocalDescription = e, e = function(e, t, r) { e = o.apply(this, [e]); return r ? (e.then(t, r), Promise.resolve()) : e }, t.setRemoteDescription = e, e = function(e, t, r) { e = s.apply(this, [e]); return r ? (e.then(t, r), Promise.resolve()) : e }, t.addIceCandidate = e) }, shimGetUserMedia: function(e) { var n = e && e.navigator; n.getUserMedia || (n.webkitGetUserMedia ? n.getUserMedia = n.webkitGetUserMedia.bind(n) : n.mediaDevices && n.mediaDevices.getUserMedia && (n.getUserMedia = function(e, t, r) { n.mediaDevices.getUserMedia(e).then(t, r) })) }, shimRTCIceServerUrls: function(e) { var a = e.RTCPeerConnection; e.RTCPeerConnection = function(e, t) { if (e && e.iceServers) { for (var r = [], n = 0; n < e.iceServers.length; n++) { var i = e.iceServers[n]; !i.hasOwnProperty('urls') && i.hasOwnProperty('url') ? (o.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (i = JSON.parse(JSON.stringify(i))).urls = i.url, delete i.url, r.push(i)) : r.push(e.iceServers[n]) }e.iceServers = r } return new a(e, t) }, e.RTCPeerConnection.prototype = a.prototype, Object.defineProperty(e.RTCPeerConnection, 'generateCertificate', { get: function() { return a.generateCertificate } }) }, shimTrackEventTransceiver: function(e) { typeof e === 'object' && e.RTCPeerConnection && 'receiver' in e.RTCTrackEvent.prototype && !e.RTCTransceiver && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function() { return { receiver: this.receiver } } }) } }; t.exports = { shimCallbacksAPI: e.shimCallbacksAPI, shimLocalStreamsAPI: e.shimLocalStreamsAPI, shimRemoteStreamsAPI: e.shimRemoteStreamsAPI, shimGetUserMedia: e.shimGetUserMedia, shimRTCIceServerUrls: e.shimRTCIceServerUrls, shimTrackEventTransceiver: e.shimTrackEventTransceiver } }, { '../utils': 13 }], 13: [function(e, t, r) { 'use strict'; var n = !0; var i = !0; var c = { disableLog: function(e) { return typeof e !== 'boolean' ? new Error('Argument type: ' + typeof e + '. Please use a boolean.') : (n = e) ? 'adapter.js logging disabled' : 'adapter.js logging enabled' }, disableWarnings: function(e) { return typeof e !== 'boolean' ? new Error('Argument type: ' + typeof e + '. Please use a boolean.') : (i = !e, 'adapter.js deprecation warnings ' + (e ? 'disabled' : 'enabled')) }, log: function() { typeof window === 'object' && (n || typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments)) }, deprecated: function(e, t) { i && console.warn(e + ' is deprecated, please use ' + t + ' instead.') }, extractVersion: function(e, t, r) { t = e.match(t); return t && t.length >= r && parseInt(t[r], 10) }, detectBrowser: function(e) { var t = e && e.navigator; var r = { browser: null, version: null }; if (void 0 === e || !e.navigator) return r.browser = 'Not a browser.', r; if (t.mozGetUserMedia)r.browser = 'firefox', r.version = this.extractVersion(t.userAgent, /Firefox\/(\d+)\./, 1); else if (t.webkitGetUserMedia) if (e.webkitRTCPeerConnection)r.browser = 'chrome', r.version = this.extractVersion(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!t.userAgent.match(/Version\/(\d+).(\d+)/)) return r.browser = 'Unsupported webkit-based browser with GUM support but no WebRTC support.', r; r.browser = 'safari', r.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1) } else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/))r.browser = 'edge', r.version = this.extractVersion(t.userAgent, /Edge\/(\d+).(\d+)$/, 2); else { if (!t.mediaDevices || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return r.browser = 'Not a supported browser.', r; r.browser = 'safari', r.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1) } return r }, shimCreateObjectURL: function(e) { var r; var t; var n; var i; var a; var o; var s = e && e.URL; typeof e === 'object' && e.HTMLMediaElement && 'srcObject' in e.HTMLMediaElement.prototype && s.createObjectURL && s.revokeObjectURL && (r = s.createObjectURL.bind(s), t = s.revokeObjectURL.bind(s), n = new Map(), i = 0, s.createObjectURL = function(e) { if ('getTracks' in e) { var t = 'polyblob:' + ++i; return n.set(t, e), c.deprecated('URL.createObjectURL(stream)', 'elem.srcObject = stream'), t } return r(e) }, s.revokeObjectURL = function(e) { t(e), n.delete(e) }, a = Object.getOwnPropertyDescriptor(e.HTMLMediaElement.prototype, 'src'), Object.defineProperty(e.HTMLMediaElement.prototype, 'src', { get: function() { return a.get.apply(this) }, set: function(e) { return this.srcObject = n.get(e) || null, a.set.apply(this, [e]) } }), o = e.HTMLMediaElement.prototype.setAttribute, e.HTMLMediaElement.prototype.setAttribute = function() { return arguments.length === 2 && ('' + arguments[0]).toLowerCase() === 'src' && (this.srcObject = n.get(arguments[1]) || null), o.apply(this, arguments) }) } }; t.exports = { log: c.log, deprecated: c.deprecated, disableLog: c.disableLog, disableWarnings: c.disableWarnings, extractVersion: c.extractVersion, shimCreateObjectURL: c.shimCreateObjectURL, detectBrowser: c.detectBrowser.bind(c) } }, {}] }, {}, [3]))(3) }))
