function Janus(s) { if (void 0 === Janus.initDone) return s.error('Library not initialized'), {}; if (!Janus.isWebrtcSupported()) return s.error('WebRTC not supported by this browser'), {}; if (Janus.log('Library initialized: ' + Janus.initDone), (s = s || {}).success = typeof s.success === 'function' ? s.success : Janus.noop, s.error = typeof s.error === 'function' ? s.error : Janus.noop, s.destroyed = typeof s.destroyed === 'function' ? s.destroyed : Janus.noop, s.server === null || void 0 === s.server) return s.error('Invalid gateway url'), {}; var i = !1; var u = null; var d = {}; var c = null; var o = null; var l = 0; var f = s.server; Janus.isArray(f) ? (Janus.log('Multiple servers provided (' + f.length + '), will use the first that works'), f = null, o = s.server, Janus.debug(o)) : f.indexOf('ws') === 0 ? (i = !0, Janus.log('Using WebSockets to contact Janus: ' + f)) : (i = !1, Janus.log('Using REST API to contact Janus: ' + f)); var g = s.iceServers; g == null && (g = [{ urls: 'stun:stun.l.google.com:19302' }]); var p = s.iceTransportPolicy; var v = s.bundlePolicy; var m = s.ipv6; m == null && (m = !1); var b = !1; void 0 !== s.withCredentials && s.withCredentials !== null && (b = !0 === s.withCredentials); var n = null; (n = void 0 !== s.max_poll_events && s.max_poll_events !== null ? s.max_poll_events : n) < 1 && (n = 1); var J = null; void 0 !== s.token && s.token !== null && (J = s.token); var w = null; void 0 !== s.apisecret && s.apisecret !== null && (w = s.apisecret), this.destroyOnUnload = !0, void 0 !== s.destroyOnUnload && s.destroyOnUnload !== null && (this.destroyOnUnload = !0 === s.destroyOnUnload); var h = !1; var y = null; var S = {}; var k = this; var D = 0; var T = {}; function C() { var e; y != null && (Janus.debug('Long poll...'), h ? (e = f + '/' + y + '?rid=' + (new Date()).getTime(), n != null && (e = e + '&maxev=' + n), J != null && (e = e + '&token=' + J), w != null && (e = e + '&apisecret=' + w), Janus.httpAPICall(e, { verb: 'GET', withCredentials: b, success: I, timeout: 6e4, error: function(e, n) { if (Janus.error(e + ': ' + n), ++D > 3) return h = !1, void s.error('Lost connection to the gateway (is it down?)'); C() } })) : Janus.warn('Is the gateway down? (connected=false)')) } function I(e, n) { var r, a, t, o; if (D = 0, i || y == null || !0 === n || setTimeout(C, 200), i || !Janus.isArray(e))e.janus === 'keepalive' ? Janus.vdebug('Got a keepalive on session ' + y) : e.janus === 'ack' ? (Janus.debug('Got an ack on session ' + y), Janus.debug(e), (a = e.transaction) != null && ((r = T[a]) != null && r(e), delete T[a])) : e.janus === 'success' ? (Janus.debug('Got a success on session ' + y), Janus.debug(e), (a = e.transaction) != null && ((r = T[a]) != null && r(e), delete T[a])) : e.janus === 'webrtcup' ? (Janus.debug('Got a webrtcup event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (o = S[t]) != null ? o.webrtcState(!0) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'hangup' ? (Janus.debug('Got a hangup event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (o = S[t]) != null ? (o.webrtcState(!1, e.reason), o.hangup()) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'detached' ? (Janus.debug('Got a detached event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (o = S[t]) != null && (o.detached = !0, o.ondetached(), o.detach()) : Janus.warn('Missing sender...')) : e.janus === 'media' ? (Janus.debug('Got a media event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (o = S[t]) != null ? o.mediaState(e.type, e.receiving) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'slowlink' ? (Janus.debug('Got a slowlink event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (o = S[t]) != null ? o.slowLink(e.uplink, e.nacks) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'error' ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), Janus.debug(e), (a = e.transaction) != null && ((r = T[a]) != null && r(e), delete T[a])) : e.janus === 'event' ? (Janus.debug('Got a plugin event on session ' + y), Janus.debug(e), (t = e.sender) != null ? (a = e.plugindata) != null ? (Janus.debug('  -- Event is coming from ' + t + ' (' + a.plugin + ')'), a = a.data, Janus.debug(a), (o = S[t]) != null ? ((t = e.jsep) != null && (Janus.debug('Handling SDP as well...'), Janus.debug(t)), (o = o.onmessage) != null ? (Janus.debug('Notifying application...'), o(a, t)) : Janus.debug('No provided notification callback')) : Janus.warn('This handle is not attached to this session')) : Janus.warn('Missing plugindata...') : Janus.warn('Missing sender...')) : (Janus.warn("Unkown message/event  '" + e.janus + "' on session " + y), Janus.debug(e)); else for (var s = 0; s < e.length; s++)I(e[s], !0) } function A() { var e; f !== null && i && h && (c = setTimeout(A, 3e4), e = { janus: 'keepalive', session_id: y, transaction: Janus.randomString(12) }, J != null && (e.token = J), w != null && (e.apisecret = w), u.send(JSON.stringify(e))) } function t(e, r) { if ((r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop, !h) return Janus.warn('Is the gateway down? (connected=false)'), void r.error('Is the gateway down? (connected=false)'); var n = r.message; var a = r.jsep; var t = Janus.randomString(12); var n = { janus: 'message', body: n, transaction: t }; if (J != null && (n.token = J), w != null && (n.apisecret = w), a != null && (n.jsep = a), Janus.debug('Sending message to plugin (handle=' + e + '):'), Janus.debug(n), i) return n.session_id = y, n.handle_id = e, T[t] = function(e) { if (Janus.debug('Message sent!'), Janus.debug(e), e.janus === 'success') { var n = e.plugindata; if (n == null) return Janus.warn('Request succeeded, but missing plugindata...'), void r.success(); Janus.log('Synchronous transaction successful (' + n.plugin + ')'); n = n.data; return Janus.debug(n), void r.success(n) }e.janus === 'ack' ? r.success() : void 0 !== e.error && e.error !== null ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), r.error(e.error.code + ' ' + e.error.reason)) : (Janus.error('Unknown error'), r.error('Unknown error')) }, void u.send(JSON.stringify(n)); Janus.httpAPICall(f + '/' + y + '/' + e, { verb: 'POST', withCredentials: b, body: n, success: function(e) { if (Janus.debug('Message sent!'), Janus.debug(e), e.janus === 'success') { var n = e.plugindata; if (n == null) return Janus.warn('Request succeeded, but missing plugindata...'), void r.success(); Janus.log('Synchronous transaction successful (' + n.plugin + ')'); n = n.data; return Janus.debug(n), void r.success(n) }e.janus === 'ack' ? r.success() : void 0 !== e.error && e.error !== null ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), r.error(e.error.code + ' ' + e.error.reason)) : (Janus.error('Unknown error'), r.error('Unknown error')) }, error: function(e, n) { Janus.error(e + ': ' + n), r.error(e + ': ' + n) } }) } function R(e, n) { if (h) { n = { janus: 'trickle', candidate: n, transaction: Janus.randomString(12) }; if (J != null && (n.token = J), w != null && (n.apisecret = w), Janus.vdebug('Sending trickle candidate (handle=' + e + '):'), Janus.vdebug(n), i) return n.session_id = y, n.handle_id = e, void u.send(JSON.stringify(n)); Janus.httpAPICall(f + '/' + y + '/' + e, { verb: 'POST', withCredentials: b, body: n, success: function(e) { Janus.vdebug('Candidate sent!'), Janus.vdebug(e), e.janus !== 'ack' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason) }, error: function(e, n) { Janus.error(e + ': ' + n) } }) } else Janus.warn('Is the gateway down? (connected=false)') } function x(e, n) { (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop; var r = S[e]; if (r == null || r.webrtcStuff === null || void 0 === r.webrtcStuff) return Janus.warn('Invalid handle'), void n.error('Invalid handle'); e = r.webrtcStuff, r = n.text; if (r == null) return Janus.warn('Invalid text'), void n.error('Invalid text'); Janus.log('Sending string on data channel: ' + r), e.dataChannel.send(r), n.success() } function O(e, n) { (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop; e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), void n.error('Invalid handle'); e = e.webrtcStuff; if ((e.dtmfSender === null || void 0 === e.dtmfSender) && (void 0 === e.myStream || e.myStream === null || (r = e.myStream.getAudioTracks()) != null && r.length > 0 && (a = r[0], e.dtmfSender = e.pc.createDTMFSender(a), Janus.log('Created DTMF Sender'), e.dtmfSender.ontonechange = function(e) { Janus.debug('Sent DTMF tone: ' + e.tone) }), e.dtmfSender === null || void 0 === e.dtmfSender)) return Janus.warn('Invalid DTMF configuration'), void n.error('Invalid DTMF configuration'); var r = n.dtmf; if (r == null) return Janus.warn('Invalid DTMF parameters'), void n.error('Invalid DTMF parameters'); var a = r.tones; if (a == null) return Janus.warn('Invalid DTMF string'), void n.error('Invalid DTMF string'); n = r.duration; n == null && (n = 500); r = r.gap; r == null && (r = 50), Janus.debug('Sending DTMF string ' + a + ' (duration ' + n + 'ms, gap ' + r + 'ms)'), e.dtmfSender.insertDTMF(a, n, r) } function j(r, a) { (a = a || {}).success = typeof a.success === 'function' ? a.success : Janus.noop, a.error = typeof a.error === 'function' ? a.error : Janus.noop, Janus.warn(a); var e = !0; if (void 0 !== a.asyncRequest && a.asyncRequest !== null && (e = !0 === a.asyncRequest), Janus.log('Destroying handle ' + r + ' (async=' + e + ')'), _(r), S[r].detached) return delete S[r], void a.success(); if (!h) return Janus.warn('Is the gateway down? (connected=false)'), void a.error('Is the gateway down? (connected=false)'); var n = { janus: 'detach', transaction: Janus.randomString(12) }; if (J != null && (n.token = J), w != null && (n.apisecret = w), i) return n.session_id = y, n.handle_id = r, u.send(JSON.stringify(n)), delete S[r], void a.success(); Janus.httpAPICall(f + '/' + y + '/' + r, { verb: 'POST', async: e, withCredentials: b, body: n, success: function(e) { Janus.log('Destroyed handle:'), Janus.debug(e), e.janus !== 'success' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), delete S[r], a.success() }, error: function(e, n) { Janus.error(e + ': ' + n), delete S[r], a.success() } }) } function M(a, e, n, t, r) { var o = S[a]; if (o == null || o.webrtcStuff === null || void 0 === o.webrtcStuff) return Janus.warn('Invalid handle'), void t.error('Invalid handle'); var s = o.webrtcStuff; Janus.debug('streamsDone:', r), s.myStream = r; var i = { iceServers: g, iceTransportPolicy: p, bundlePolicy: v }; var u = { optional: [{ DtlsSrtpKeyAgreement: !0 }] }; !0 === m && u.optional.push({ googIPv6: !0 }), Janus.webRTCAdapter.browserDetails.browser === 'edge' && (i.bundlePolicy = 'max-bundle'), Janus.log('Creating PeerConnection'), Janus.debug(u), s.pc = new RTCPeerConnection(i, u), Janus.debug(s.pc), s.pc.getStats && (s.volume.value = 0, s.bitrate.value = '0 kbits/sec'), Janus.log('Preparing local SDP and gathering candidates (trickle=' + s.trickle + ')'), s.pc.oniceconnectionstatechange = function(e) { s.pc && o.iceState(s.pc.iceConnectionState) }, s.pc.onicecandidate = function(e) { var n, r; e.candidate == null || Janus.webRTCAdapter.browserDetails.browser === 'edge' && e.candidate.candidate.indexOf('endOfCandidates') > 0 ? (Janus.log('End of candidates.'), (s.iceDone = !0) === s.trickle ? R(a, { completed: !0 }) : (n = a, (r = (r = t) || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop, (n = S[n]) == null || n.webrtcStuff === null || void 0 === n.webrtcStuff ? Janus.warn('Invalid handle, not sending anything') : (n = n.webrtcStuff, Janus.log('Sending offer/answer SDP...'), n.mySdp === null || void 0 === n.mySdp ? Janus.warn('Local SDP instance is invalid, not sending anything...') : (n.mySdp = { type: n.pc.localDescription.type, sdp: n.pc.localDescription.sdp }, n.sdpSent ? Janus.log('Offer/Answer SDP already sent, not sending it again') : (!1 === n.trickle && (n.mySdp.trickle = !1), Janus.debug(r), n.sdpSent = !0, r.success(n.mySdp)))))) : (e = { candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex }, !0 === s.trickle && R(a, e)) }, r != null && (Janus.log('Adding local stream'), r.getTracks().forEach(e => s.pc.addTrack(e, r)), o.onlocalstream(r)), s.pc.ontrack = function(e) { Janus.log('Handling Remote Track'), Janus.debug(e), e.streams && (s.remoteStream = e.streams[0], o.onremotestream(s.remoteStream)) }, u = n, Janus.debug('isDataEnabled:', u), (Janus.webRTCAdapter.browserDetails.browser != 'edge' ? u == null || !0 !== u.data : (Janus.warn("Edge doesn't support data channels yet"), 1)) || (Janus.log('Creating data channel'), u = function() { var e = s.dataChannel !== null ? s.dataChannel.readyState : 'null'; Janus.log('State change on data channel: ' + e), e === 'open' && o.ondataopen() }, s.dataChannel = s.pc.createDataChannel('JanusDataChannel', { ordered: !1 }), s.dataChannel.onmessage = function(e) { Janus.log('Received message on data channel: ' + e.data), o.ondata(e.data) }, s.dataChannel.onopen = u, s.dataChannel.onclose = u, s.dataChannel.onerror = function(e) { Janus.error('Got error on data channel:', e) }), e == null ? F(a, n, t) : s.pc.setRemoteDescription(new RTCSessionDescription(e), function() { Janus.log('Remote description accepted!'), L(a, n, t) }, t.error) } function P(s, i) { (i = i || {}).success = typeof i.success === 'function' ? i.success : Janus.noop, i.error = typeof i.error === 'function' ? i.error : q; var u = i.jsep; var d = i.media; var c = S[s]; if (c == null || c.webrtcStuff === null || void 0 === c.webrtcStuff) return Janus.warn('Invalid handle'), void i.error('Invalid handle'); var e; var n = c.webrtcStuff; if (void 0 !== n.pc && n.pc !== null) return Janus.log('Updating existing media session'), void (u == null ? F(s, d, i) : n.pc.setRemoteDescription(new RTCSessionDescription(u), function() { Janus.log('Remote description accepted!'), L(s, d, i) }, i.error)); if (n.trickle = (e = i.trickle, Janus.debug('isTrickleEnabled:', e), e == null || !0 === e), i.stream !== null && void 0 !== i.stream) { var r = i.stream; return Janus.log('MediaStream provided by the application'), Janus.debug(r), n.streamExternal = !0, void M(s, u, d, i, r) } if (G(d) || H(d)) { var a = { mandatory: {}, optional: [] }; c.consentDialog(!0); var l = G(d); !0 === l && d != null && d != null && typeof d.audio === 'object' && (l = d.audio); var f = H(d); if (!0 === f && d != null && d != null) if (!(!0 === i.simulcast) || u || void 0 !== d.video && !1 !== d.video || (d.video = 'hires'), d.video && d.video != 'screen' && d.video != 'window') { var t = 0; var o = 0; var r = 0; d.video === 'lowres' ? (r = o = 240, t = 320) : d.video === 'lowres-16:9' ? (r = o = 180, t = 320) : d.video === 'hires' || d.video === 'hires-16:9' ? (r = o = 720, t = 1280, navigator.mozGetUserMedia && parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) < 38 && (Janus.warn(d.video + ' unsupported, falling back to stdres (old Firefox)'), r = o = 480, t = 640)) : t = (r = o = d.video === 'stdres' ? 480 : d.video === 'stdres-16:9' ? 360 : (Janus.log('Default video setting is stdres 4:3'), 480), 640), Janus.log('Adding media constraint:', d.video), f = navigator.mozGetUserMedia ? parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) < 38 ? { require: ['height', 'width'], height: { max: r, min: o }, width: { max: t, min: t } } : { height: { ideal: o }, width: { ideal: t } } : { mandatory: { maxHeight: r, minHeight: o, maxWidth: t, minWidth: t }, optional: [] }, typeof d.video === 'object' && (f = d.video), Janus.debug(f) } else if (d.video === 'screen' || d.video === 'window') { if (d.screenshareFrameRate || (d.screenshareFrameRate = 3), window.location.protocol !== 'https:') return Janus.warn('Screen sharing only works on HTTPS, try the https:// version of this page'), c.consentDialog(!1), void i.error('Screen sharing only works on HTTPS, try the https:// version of this page'); var g = {}; function p(e, n) { c.consentDialog(!1), e ? i.error({ code: e.code, name: e.name, message: e.message }) : M(s, u, d, i, n) } function v(e, r, a) { Janus.log('Adding media constraint (screen capture)'), Janus.debug(e), navigator.mediaDevices.getUserMedia(e).then(function(n) { a ? navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }).then(function(e) { n.addTrack(e.getAudioTracks()[0]), r(null, n) }) : r(null, n) }).catch(function(e) { c.consentDialog(!1), r(e) }) } if (Janus.webRTCAdapter.browserDetails.browser === 'chrome') { o = Janus.webRTCAdapter.browserDetails.version, t = 33; window.navigator.userAgent.match('Linux') && (t = 35), o >= 26 && o <= t ? v(a = { video: { mandatory: { googLeakyBucket: !0, maxWidth: window.screen.width, maxHeight: window.screen.height, minFrameRate: d.screenshareFrameRate, maxFrameRate: d.screenshareFrameRate, chromeMediaSource: 'screen' } }, audio: G(d) }, p) : (t = window.setTimeout(function() { return (m = new Error('NavigatorUserMediaError')).name = 'The required Chrome extension is not installed: click <a href="#">here</a> to install it. (NOTE: this will need you to refresh the page)', c.consentDialog(!1), i.error(m) }, 1e3), g[t] = [p, null], window.postMessage({ type: 'janusGetScreen', id: t }, '*')) } else if (window.navigator.userAgent.match('Firefox')) { if (!(parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) >= 33)) { var m = new Error('NavigatorUserMediaError'); return m.name = 'Your version of Firefox does not support screen sharing, please install Firefox 33 (or more recent versions)', c.consentDialog(!1), void i.error(m) }v(a = { video: { mozMediaSource: d.video, mediaSource: d.video }, audio: G(d) }, function(e, n) { var r, a; p(e, n), e || (r = n.currentTime, a = window.setInterval(function() { n || window.clearInterval(a), n.currentTime == r && (window.clearInterval(a), n.onended && n.onended()), r = n.currentTime }, 500)) }) } return void window.addEventListener('message', function(e) { var n, r; e.origin == window.location.origin && (e.data.type == 'janusGotScreen' && g[e.data.id] ? (n = g[e.data.id][0], delete g[e.data.id], e.data.sourceId === '' ? ((r = new Error('NavigatorUserMediaError')).name = 'You cancelled the request for permission, giving up...', c.consentDialog(!1), i.error(r)) : ((a = { audio: !1, video: { mandatory: { chromeMediaSource: 'desktop', maxWidth: window.screen.width, maxHeight: window.screen.height, minFrameRate: d.screenshareFrameRate, maxFrameRate: d.screenshareFrameRate }, optional: [{ googLeakyBucket: !0 }, { googTemporalLayeredScreencast: !0 }] } }).video.mandatory.chromeMediaSourceId = e.data.sourceId, v(a, n, G(d)))) : e.data.type == 'janusGetScreenPending' && window.clearTimeout(e.data.id)) }) }d != null && d.video === 'screen' || navigator.mediaDevices.enumerateDevices().then(function(e) { var n; var r = e.some(function(e) { return e.kind === 'audioinput' }); var a = e.some(function(e) { return e.kind === 'videoinput' }); var t = G(d); var o = H(d); var e = (n = d, Janus.debug('isAudioSendRequired:', n), n != null && (!1 !== n.audio && !1 !== n.audioSend && (void 0 !== n.failIfNoAudio && n.failIfNoAudio !== null && !0 === n.failIfNoAudio))); var n = (n = d, Janus.debug('isVideoSendRequired:', n), n != null && (!1 !== n.video && !1 !== n.videoSend && (void 0 !== n.failIfNoVideo && n.failIfNoVideo !== null && !0 === n.failIfNoVideo))); if (t || o || e || n) { t = !!t && r, o = !!o && a; if (!t && !o) return c.consentDialog(!1), i.error('No capture device found'), !1; if (!t && e) return c.consentDialog(!1), i.error('Audio capture is required, but no capture device found'), !1; if (!o && n) return c.consentDialog(!1), i.error('Video capture is required, but no capture device found'), !1 }navigator.mediaDevices.getUserMedia({ audio: !!r && l, video: !!a && f }).then(function(e) { c.consentDialog(!1), M(s, u, d, i, e) }).catch(function(e) { c.consentDialog(!1), i.error({ code: e.code, name: e.name, message: e.message }) }) }).catch(function(e) { c.consentDialog(!1), i.error('enumerateDevices error', e) }) } else M(s, u, d, i) } function E(e, n) { (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : q; var r = n.jsep; var e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), void n.error('Invalid handle'); e = e.webrtcStuff; if (r != null) { if (e.pc === null) return Janus.warn('Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep'), void n.error('No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep'); e.pc.setRemoteDescription(new RTCSessionDescription(r), function() { Janus.log('Remote description accepted!'), n.success() }, n.error) } else n.error('Invalid JSEP') } function F(e, n, r) { (r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop; var a = S[e]; if (a == null || a.webrtcStuff === null || void 0 === a.webrtcStuff) return Janus.warn('Invalid handle'), void r.error('Invalid handle'); var t = a.webrtcStuff; var o = !0 === r.simulcast; o ? Janus.log('Creating offer (iceDone=' + t.iceDone + ', simulcast=' + o + ')') : Janus.log('Creating offer (iceDone=' + t.iceDone + ')'); e = null, e = Janus.webRTCAdapter.browserDetails.browser == 'firefox' || Janus.webRTCAdapter.browserDetails.browser == 'edge' ? { offerToReceiveAudio: B(n), offerToReceiveVideo: z(n) } : { mandatory: { OfferToReceiveAudio: B(n), OfferToReceiveVideo: z(n) } }; Janus.debug(e); var s = H(n); s && o && adapter.browserDetails.browser === 'firefox' && (Janus.log('Enabling Simulcasting for Firefox (RID)'), a = t.pc.getSenders()[1], Janus.log(a), n = a.getParameters(), Janus.log(n), a.setParameters({ encodings: [{ rid: 'high', active: !0, priority: 'high', maxBitrate: 1e6 }, { rid: 'medium', active: !0, priority: 'medium', maxBitrate: 3e5 }, { rid: 'low', active: !0, priority: 'low', maxBitrate: 1e5 }] })), t.pc.createOffer(function(e) { Janus.debug(e), t.mySdp !== null && void 0 !== t.mySdp || (Janus.log('Setting local description'), s && o && (adapter.browserDetails.browser === 'chrome' ? (Janus.log('Enabling Simulcasting for Chrome (SDP munging)'), e.sdp = (function(e) { for (var n = e.split('\r\n'), r = !1, a = [-1], t = -1, o = null, s = null, i = null, u = null, d = -1, c = 0; c < n.length; c++) { var l = n[c].match(/m=(\w+) */); if (l) { if (l[1] === 'video') { if (!(a[0] < 0)) { d = c; break }r = !0 } else if (a[0] > -1) { d = c; break } } else if (r) { var f = n[c].match(/a=ssrc-group:FID (\d+) (\d+)/); if (f)a[0] = f[1], t = f[2], n.splice(c, 1), c--; else { if (a[0]) { if ((g = n[c].match('a=ssrc:' + a[0] + ' cname:(.+)')) && (o = g[1]), (g = n[c].match('a=ssrc:' + a[0] + ' msid:(.+)')) && (s = g[1]), (g = n[c].match('a=ssrc:' + a[0] + ' mslabel:(.+)')) && (i = g[1]), (g = n[c].match('a=ssrc:' + a + ' label:(.+)')) && (u = g[1]), n[c].indexOf('a=ssrc:' + t) === 0) { n.splice(c, 1), c--; continue } if (n[c].indexOf('a=ssrc:' + a[0]) === 0) { n.splice(c, 1), c--; continue } }n[c].length != 0 || (n.splice(c, 1), c--) } } } if (a[0] < 0) { r = !(d = -1); for (c = 0; c < n.length; c++) { var g; var l = n[c].match(/m=(\w+) */); if (l) { if (l[1] === 'video') { if (!(a[0] < 0)) { d = c; break }r = !0 } else if (a[0] > -1) { d = c; break } } else if (r) { if (a[0] < 0) { var p = n[c].match(/a=ssrc:(\d+)/); if (p) { a[0] = p[1], n.splice(c, 1), c--; continue } } else { if ((g = n[c].match('a=ssrc:' + a[0] + ' cname:(.+)')) && (o = g[1]), (g = n[c].match('a=ssrc:' + a[0] + ' msid:(.+)')) && (s = g[1]), (g = n[c].match('a=ssrc:' + a[0] + ' mslabel:(.+)')) && (i = g[1]), (g = n[c].match('a=ssrc:' + a + ' label:(.+)')) && (u = g[1]), n[c].indexOf('a=ssrc:' + t) === 0) { n.splice(c, 1), c--; continue } if (n[c].indexOf('a=ssrc:' + a[0]) === 0) { n.splice(c, 1), c--; continue } }n[c].length != 0 || (n.splice(c, 1), c--) } } } if (a[0] < 0) return Janus.warn("Couldn't find the video SSRC, simulcasting NOT enabled"), e; d < 0 && (d = n.length); a[1] = Math.floor(4294967295 * Math.random()), a[2] = Math.floor(4294967295 * Math.random()); for (c = 0; c < a.length; c++)o && (n.splice(d, 0, 'a=ssrc:' + a[c] + ' cname:' + o), d++), s && (n.splice(d, 0, 'a=ssrc:' + a[c] + ' msid:' + s), d++), i && (n.splice(d, 0, 'a=ssrc:' + a[c] + ' mslabel:' + s), d++), u && (n.splice(d, 0, 'a=ssrc:' + a[c] + ' label:' + s), d++); n.splice(d, 0, 'a=ssrc-group:SIM ' + a[0] + ' ' + a[1] + ' ' + a[2]), (e = n.join('\r\n')).endsWith('\r\n') || (e += '\r\n'); return e }(e.sdp))) : adapter.browserDetails.browser !== 'firefox' && Janus.warn('simulcast=true, but this is not Chrome nor Firefox, ignoring')), t.mySdp = e.sdp, t.pc.setLocalDescription(e)), t.iceDone || t.trickle ? t.sdpSent ? Janus.log('Offer already sent, not sending it again') : (Janus.log('Offer ready'), Janus.debug(r), t.sdpSent = !0, e = { type: e.type, sdp: e.sdp }, r.success(e)) : Janus.log('Waiting for all candidates...') }, r.error, e) } function L(e, n, r) { (r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop; var a = S[e]; if (a == null || a.webrtcStuff === null || void 0 === a.webrtcStuff) return Janus.warn('Invalid handle'), void r.error('Invalid handle'); var t = a.webrtcStuff; var o = !0 === r.simulcast; o ? Janus.log('Creating answer (iceDone=' + t.iceDone + ', simulcast=' + o + ')') : Janus.log('Creating answer (iceDone=' + t.iceDone + ')'); e = null, e = Janus.webRTCAdapter.browserDetails.browser == 'firefox' || Janus.webRTCAdapter.browserDetails.browser == 'edge' ? { offerToReceiveAudio: B(n), offerToReceiveVideo: z(n) } : { mandatory: { OfferToReceiveAudio: B(n), OfferToReceiveVideo: z(n) } }; Janus.debug(e); var s = H(n); s && o && adapter.browserDetails.browser === 'firefox' && (Janus.log('Enabling Simulcasting for Firefox (RID)'), a = t.pc.getSenders()[1], Janus.log(a), n = a.getParameters(), Janus.log(n), a.setParameters({ encodings: [{ rid: 'high', active: !0, priority: 'high', maxBitrate: 1e6 }, { rid: 'medium', active: !0, priority: 'medium', maxBitrate: 3e5 }, { rid: 'low', active: !0, priority: 'low', maxBitrate: 1e5 }] })), t.pc.createAnswer(function(e) { Janus.debug(e), t.mySdp !== null && void 0 !== t.mySdp || (Janus.log('Setting local description'), s && o && (adapter.browserDetails.browser === 'chrome' ? Janus.warn('simulcast=true, but this is an answer, and video breaks in Chrome if we enable it') : adapter.browserDetails.browser !== 'firefox' && Janus.warn('simulcast=true, but this is not Chrome nor Firefox, ignoring')), t.mySdp = e.sdp, t.pc.setLocalDescription(e)), t.iceDone || t.trickle ? t.sdpSent ? Janus.log('Answer already sent, not sending it again') : (t.sdpSent = !0, e = { type: e.type, sdp: e.sdp }, r.success(e)) : Janus.log('Waiting for all candidates...') }, r.error, e) } function N(e) { e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), 0; var t = e.webrtcStuff; return t.pc.getStats && Janus.webRTCAdapter.browserDetails.browser == 'chrome' ? t.remoteStream === null || void 0 === t.remoteStream ? (Janus.warn('Remote stream unavailable'), 0) : t.volume.timer === null || void 0 === t.volume.timer ? (Janus.log('Starting volume monitor'), t.volume.timer = setInterval(function() { t.pc.getStats(function(e) { for (var n = e.result(), r = 0; r < n.length; r++) { var a = n[r]; a.type == 'ssrc' && a.stat('audioOutputLevel') && (t.volume.value = a.stat('audioOutputLevel')) } }) }, 200), 0) : t.volume.value : (Janus.log('Getting the remote volume unsupported by browser'), 0) } function U(e, n) { e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), !0; e = e.webrtcStuff; return e.pc === null || void 0 === e.pc ? (Janus.warn('Invalid PeerConnection'), !0) : void 0 === e.myStream || e.myStream === null ? (Janus.warn('Invalid local MediaStream'), !0) : n ? e.myStream.getVideoTracks() === null || void 0 === e.myStream.getVideoTracks() || e.myStream.getVideoTracks().length === 0 ? (Janus.warn('No video track'), !0) : !e.myStream.getVideoTracks()[0].enabled : e.myStream.getAudioTracks() === null || void 0 === e.myStream.getAudioTracks() || e.myStream.getAudioTracks().length === 0 ? (Janus.warn('No audio track'), !0) : !e.myStream.getAudioTracks()[0].enabled } function V(e, n, r) { e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), !1; e = e.webrtcStuff; return e.pc === null || void 0 === e.pc ? (Janus.warn('Invalid PeerConnection'), !1) : void 0 === e.myStream || e.myStream === null ? (Janus.warn('Invalid local MediaStream'), !1) : n ? e.myStream.getVideoTracks() === null || void 0 === e.myStream.getVideoTracks() || e.myStream.getVideoTracks().length === 0 ? (Janus.warn('No video track'), !1) : (e.myStream.getVideoTracks()[0].enabled = !r, !0) : e.myStream.getAudioTracks() === null || void 0 === e.myStream.getAudioTracks() || e.myStream.getAudioTracks().length === 0 ? (Janus.warn('No audio track'), !1) : (e.myStream.getAudioTracks()[0].enabled = !r, !0) } function W(e) { e = S[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), 'Invalid handle'; var r = e.webrtcStuff; return r.pc === null || void 0 === r.pc ? 'Invalid PeerConnection' : r.pc.getStats ? r.bitrate.timer === null || void 0 === r.bitrate.timer ? (Janus.log('Starting bitrate timer (via getStats)'), r.bitrate.timer = setInterval(function() { r.pc.getStats().then(function(e) { e.forEach(function(e) { var n; e && (n = !1, (n = (e.mediaType === 'video' || e.id.toLowerCase().indexOf('video') > -1) && e.type === 'inbound-rtp' && e.id.indexOf('rtcp') < 0 || e.type == 'ssrc' && e.bytesReceived && (e.googCodecName === 'VP8' || e.googCodecName === '') ? !0 : n) && (r.bitrate.bsnow = e.bytesReceived, r.bitrate.tsnow = e.timestamp, r.bitrate.bsbefore === null || r.bitrate.tsbefore === null || (e = r.bitrate.tsnow - r.bitrate.tsbefore, adapter.browserDetails.browser == 'safari' && (e /= 1e3), e = Math.round(8 * (r.bitrate.bsnow - r.bitrate.bsbefore) / e), r.bitrate.value = e + ' kbits/sec'), r.bitrate.bsbefore = r.bitrate.bsnow, r.bitrate.tsbefore = r.bitrate.tsnow)) }) }) }, 1e3), '0 kbits/sec') : r.bitrate.value : (Janus.warn('Getting the video bitrate unsupported by browser'), 'Feature unsupported by browser') } function q(e) { Janus.error('WebRTC error:', e) } function _(e, n) { Janus.log('Cleaning WebRTC stuff'); var r = S[e]; if (r != null) { var a = r.webrtcStuff; if (a != null) { !0 === n && (n = { janus: 'hangup', transaction: Janus.randomString(12) }, J != null && (n.token = J), w != null && (n.apisecret = w), Janus.debug('Sending hangup request (handle=' + e + '):'), Janus.debug(n), i ? (n.session_id = y, n.handle_id = e, u.send(JSON.stringify(n))) : Janus.httpAPICall(f + '/' + y + '/' + e, { verb: 'POST', withCredentials: b, data: n })), a.remoteStream = null, a.volume.timer && clearInterval(a.volume.timer), a.volume.value = null, a.bitrate.timer && clearInterval(a.bitrate.timer), a.bitrate.timer = null, a.bitrate.bsnow = null, a.bitrate.bsbefore = null, a.bitrate.tsnow = null, a.bitrate.tsbefore = null, a.bitrate.value = null; try { if (!a.streamExternal && a.myStream !== null && void 0 !== a.myStream) { Janus.log('Stopping local stream tracks'); var t; var o = a.myStream.getTracks(); for (t in o) { var s = o[t]; Janus.log(s), s != null && s.stop() } } } catch (e) {}a.streamExternal = !1, a.myStream = null; try { a.pc.close() } catch (e) {}a.pc = null, a.mySdp = null, a.iceDone = !1, a.sdpSent = !1, a.dataChannel = null, a.dtmfSender = null }r.oncleanup() } } function G(e) { return Janus.debug('isAudioSendEnabled:', e), e == null || !1 !== e.audio && (void 0 === e.audioSend || e.audioSend === null || !0 === e.audioSend) } function B(e) { return Janus.debug('isAudioRecvEnabled:', e), e == null || !1 !== e.audio && (void 0 === e.audioRecv || e.audioRecv === null || !0 === e.audioRecv) } function H(e) { return Janus.debug('isVideoSendEnabled:', e), e == null || !1 !== e.video && (void 0 === e.videoSend || e.videoSend === null || !0 === e.videoSend) } function z(e) { return Janus.debug('isVideoRecvEnabled:', e), e == null || !1 !== e.video && (void 0 === e.videoRecv || e.videoRecv === null || !0 === e.videoRecv) }!(function r(a) { var e = Janus.randomString(12); var n = { janus: 'create', transaction: e }; J != null && (n.token = J); w != null && (n.apisecret = w); f === null && Janus.isArray(o) && ((f = o[l]).indexOf('ws') === 0 ? (i = !0, Janus.log('Server #' + (l + 1) + ': trying WebSockets to contact Janus (' + f + ')')) : (i = !1, Janus.log('Server #' + (l + 1) + ': trying REST API to contact Janus (' + f + ')'))); if (i) { for (var t in u = Janus.newWebSocket(f, 'janus-protocol'), d = { error: function() { if (Janus.error('Error connecting to the Janus WebSockets server... ' + f), Janus.isArray(o)) return ++l == o.length ? void a.error('Error connecting to any of the provided Janus servers: Is the gateway down?') : (f = null, void setTimeout(function() { r(a) }, 200)); a.error('Error connecting to the Janus WebSockets server: Is the gateway down?') }, open: function() { T[e] = function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void a.error(e.error.reason); c = setTimeout(A, 3e4), h = !0, y = e.data.id, Janus.log('Created session: ' + y), Janus.sessions[y] = k, a.success() }, u.send(JSON.stringify(n)) }, message: function(e) { I(JSON.parse(e.data)) }, close: function() { f !== null && h && s.error('Lost connection to the gateway (is it down?)') } })u.addEventListener(t, d[t]); return }Janus.httpAPICall(f, { verb: 'POST', withCredentials: b, body: n, success: function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void a.error(e.error.reason); h = !0, y = e.data.id, Janus.log('Created session: ' + y), Janus.sessions[y] = k, C(), a.success() }, error: function(e, n) { if (Janus.error(e + ': ' + n), Janus.isArray(o)) return ++l == o.length ? void a.error('Error connecting to any of the provided Janus servers: Is the gateway down?') : (f = null, void setTimeout(function() { r(a) }, 200)); n === '' ? a.error(e + ': Is the gateway down?') : a.error(e + ': ' + n) } }) }(s)), this.getServer = function() { return f }, this.isConnected = function() { return h }, this.getSessionId = function() { return y }, this.destroy = function(e) { !(function(r) { (r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop; var e = !0; if (void 0 !== r.asyncRequest && r.asyncRequest !== null && (e = !0 === r.asyncRequest), Janus.log('Destroying session ' + y + ' (async=' + e + ')'), !h) return Janus.warn('Is the gateway down? (connected=false)'), r.success(); if (y == null) return Janus.warn('No session to destroy'), r.success(), s.destroyed(); delete Janus.sessions[y]; var n = { janus: 'destroy', transaction: Janus.randomString(12) }; if (J != null && (n.token = J), w != null && (n.apisecret = w), i) { n.session_id = y; function a() { for (var e in d)u.removeEventListener(e, d[e]); u.removeEventListener('message', t), u.removeEventListener('error', o), c && clearTimeout(c) } var t = function(e) { e = JSON.parse(e.data); e.session_id == n.session_id && e.transaction == n.transaction && (a(), r.success(), s.destroyed()) }; var o = function(e) { a(), r.error('Failed to destroy the gateway: Is the gateway down?'), s.destroyed() }; return u.addEventListener('message', t), u.addEventListener('error', o), u.send(JSON.stringify(n)) }console.log(resuest, 'request====================='), Janus.httpAPICall(f + '/' + y, { verb: 'POST', async: e, withCredentials: b, body: n, success: function(e) { Janus.log('Destroyed session:'), Janus.debug(e), y = null, h = !1, e.janus !== 'success' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), r.success(), s.destroyed() }, error: function(e, n) { Janus.error(e + ': ' + n), y = null, h = !1, r.success(), s.destroyed() } }) }(e)) }, this.attach = function(e) { !(function(r) { if ((r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop, r.consentDialog = typeof r.consentDialog === 'function' ? r.consentDialog : Janus.noop, r.iceState = typeof r.iceState === 'function' ? r.iceState : Janus.noop, r.mediaState = typeof r.mediaState === 'function' ? r.mediaState : Janus.noop, r.webrtcState = typeof r.webrtcState === 'function' ? r.webrtcState : Janus.noop, r.slowLink = typeof r.slowLink === 'function' ? r.slowLink : Janus.noop, r.onmessage = typeof r.onmessage === 'function' ? r.onmessage : Janus.noop, r.onlocalstream = typeof r.onlocalstream === 'function' ? r.onlocalstream : Janus.noop, r.onremotestream = typeof r.onremotestream === 'function' ? r.onremotestream : Janus.noop, r.ondata = typeof r.ondata === 'function' ? r.ondata : Janus.noop, r.ondataopen = typeof r.ondataopen === 'function' ? r.ondataopen : Janus.noop, r.oncleanup = typeof r.oncleanup === 'function' ? r.oncleanup : Janus.noop, r.ondetached = typeof r.ondetached === 'function' ? r.ondetached : Janus.noop, !h) return Janus.warn('Is the gateway down? (connected=false)'), r.error('Is the gateway down? (connected=false)'); var a = r.plugin; if (a == null) return Janus.error('Invalid plugin'), r.error('Invalid plugin'); var e = r.opaqueId; var n = Janus.randomString(12); var e = { janus: 'attach', plugin: a, opaque_id: e, transaction: n }; if (J != null && (e.token = J), w != null && (e.apisecret = w), adapter.browserDetails.browser != 'chrome' && adapter.browserDetails.browser != 'firefox' && adapter.browserDetails.browser != 'safari' || (e['force-bundle'] = !0, e['force-rtcp-mux'] = !0), i) return T[n] = function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void r.error('Ooops: ' + e.error.code + ' ' + e.error.reason); var n = e.data.id; Janus.log('Created handle: ' + n); e = { session: k, plugin: a, id: n, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, remoteStream: null, mySdp: null, pc: null, dataChannel: null, dtmfSender: null, trickle: !0, iceDone: !1, sdpSent: !1, volume: { value: null, timer: null }, bitrate: { value: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, timer: null } }, getId: function() { return n }, getPlugin: function() { return a }, getVolume: function() { return N(n) }, isAudioMuted: function() { return U(n, !1) }, muteAudio: function() { return V(n, !1, !0) }, unmuteAudio: function() { return V(n, !1, !1) }, isVideoMuted: function() { return U(n, !0) }, muteVideo: function() { return V(n, !0, !0) }, unmuteVideo: function() { return V(n, !0, !1) }, getBitrate: function() { return W(n) }, send: function(e) { t(n, e) }, data: function(e) { x(n, e) }, dtmf: function(e) { O(n, e) }, consentDialog: r.consentDialog, iceState: r.iceState, mediaState: r.mediaState, webrtcState: r.webrtcState, slowLink: r.slowLink, onmessage: r.onmessage, createOffer: function(e) { P(n, e) }, createAnswer: function(e) { P(n, e) }, handleRemoteJsep: function(e) { E(n, e) }, onlocalstream: r.onlocalstream, onremotestream: r.onremotestream, ondata: r.ondata, ondataopen: r.ondataopen, oncleanup: r.oncleanup, ondetached: r.ondetached, hangup: function(e) { _(n, !0 === e) }, detach: function(e) { j(n, e) } }; S[n] = e, r.success(e) }, e.session_id = y, u.send(JSON.stringify(e)); Janus.httpAPICall(f + '/' + y, { verb: 'POST', withCredentials: b, body: e, success: function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void r.error('Ooops: ' + e.error.code + ' ' + e.error.reason); var n = e.data.id; Janus.log('Created handle: ' + n); e = { session: k, plugin: a, id: n, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, remoteStream: null, mySdp: null, pc: null, dataChannel: null, dtmfSender: null, trickle: !0, iceDone: !1, sdpSent: !1, volume: { value: null, timer: null }, bitrate: { value: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, timer: null } }, getId: function() { return n }, getPlugin: function() { return a }, getVolume: function() { return N(n) }, isAudioMuted: function() { return U(n, !1) }, muteAudio: function() { return V(n, !1, !0) }, unmuteAudio: function() { return V(n, !1, !1) }, isVideoMuted: function() { return U(n, !0) }, muteVideo: function() { return V(n, !0, !0) }, unmuteVideo: function() { return V(n, !0, !1) }, getBitrate: function() { return W(n) }, send: function(e) { t(n, e) }, data: function(e) { x(n, e) }, dtmf: function(e) { O(n, e) }, consentDialog: r.consentDialog, iceState: r.iceState, mediaState: r.mediaState, webrtcState: r.webrtcState, slowLink: r.slowLink, onmessage: r.onmessage, createOffer: function(e) { P(n, e) }, createAnswer: function(e) { P(n, e) }, handleRemoteJsep: function(e) { E(n, e) }, onlocalstream: r.onlocalstream, onremotestream: r.onremotestream, ondata: r.ondata, ondataopen: r.ondataopen, oncleanup: r.oncleanup, ondetached: r.ondetached, hangup: function(e) { _(n, !0 === e) }, detach: function(e) { j(n, e) } }; S[n] = e, r.success(e) }, error: function(e, n) { Janus.error(e + ': ' + n) } }) }(e)) } }Janus.sessions = {}, Janus.extensionId = 'hapfgfdkleiggjjpfpenajgdnfckjpaj', Janus.isExtensionEnabled = function() { if (window.navigator.userAgent.match('Chrome')) { var e = parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10); var n = 33; return window.navigator.userAgent.match('Linux') && (n = 35), e >= 26 && e <= n || Janus.checkJanusExtension() } return !0 }, Janus.useDefaultDependencies = function(e) { var r = e && e.fetch || fetch; var t = e && e.Promise || Promise; var a = e && e.WebSocket || WebSocket; return { newWebSocket: function(e, n) { return new a(e, n) }, isArray: function(e) { return Array.isArray(e) }, checkJanusExtension: function() { return document.querySelector('#janus-extension-installed') !== null }, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function(e, a) { var n = { method: a.verb, cache: 'no-cache' }; void 0 !== a.withCredentials && (n.credentials = !0 === a.withCredentials ? 'include' : a.withCredentials || 'omit'), void 0 !== a.body && (n.body = JSON.stringify(a.body)); e = r(e, n).catch(function(e) { return t.reject({ message: 'Probably a network error, is the gateway down?', error: e }) }); return void 0 !== a.timeout && (n = new t(function(e, n) { var r = setTimeout(function() { return clearTimeout(r), n({ message: 'Request timed out', timeout: a.timeout }) }, a.timeout) }), e = t.race([e, n])), e.then(function(n) { return n.ok ? typeof a.success === typeof Janus.noop ? n.json().then(function(e) { a.success(e) }).catch(function(e) { return t.reject({ message: 'Failed to parse response body', error: e, response: n }) }) : void 0 : t.reject({ message: 'API call failed', response: n }) }).catch(function(e) { typeof a.error === typeof Janus.noop && a.error(e.message || '<< internal error >>', e) }), e } } }, Janus.useOldDependencies = function(e) { var t = e && e.jQuery || jQuery; var r = e && e.WebSocket || WebSocket; return { newWebSocket: function(e, n) { return new r(e, n) }, isArray: function(e) { return t.isArray(e) }, checkJanusExtension: function() { return t('#janus-extension-installed').length > 0 }, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function(e, a) { var n = void 0 !== a.body ? { contentType: 'application/json', data: JSON.stringify(a.body) } : {}; var r = void 0 !== a.withCredentials ? { xhrFields: { withCredentials: a.withCredentials } } : {}; return t.ajax(t.extend(n, r, { url: e, type: a.verb, cache: !1, dataType: 'json', async: a.async, timeout: a.timeout, success: function(e) { typeof a.success === typeof Janus.noop && a.success(e) }, error: function(e, n, r) { typeof a.error === typeof Janus.noop && a.error(n, r) } })) } } }, Janus.noop = function() {}, Janus.init = function(e) { if ((e = e || {}).callback = typeof e.callback === 'function' ? e.callback : Janus.noop, !0 === Janus.initDone)e.callback(); else { if (typeof console !== 'undefined' && void 0 !== console.log || (console = { log: function() {} }), Janus.trace = Janus.noop, Janus.debug = Janus.noop, Janus.vdebug = Janus.noop, Janus.log = Janus.noop, Janus.warn = Janus.noop, Janus.error = Janus.noop, !0 === e.debug || e.debug === 'all')Janus.trace = console.trace.bind(console), Janus.debug = console.debug.bind(console), Janus.vdebug = console.debug.bind(console), Janus.log = console.log.bind(console), Janus.warn = console.warn.bind(console), Janus.error = console.error.bind(console); else if (Array.isArray(e.debug)) for (var n in e.debug) { var r = e.debug[n]; switch (r) { case 'trace':Janus.trace = console.trace.bind(console); break; case 'debug':Janus.debug = console.debug.bind(console); break; case 'vdebug':Janus.vdebug = console.debug.bind(console); break; case 'log':Janus.log = console.log.bind(console); break; case 'warn':Janus.warn = console.warn.bind(console); break; case 'error':Janus.error = console.error.bind(console); break; default:console.error("Unknown debugging option '" + r + "' (supported: 'trace', 'debug', 'vdebug', 'log', warn', 'error')") } }Janus.log('Initializing library'); var a = e.dependencies || Janus.useDefaultDependencies(); Janus.isArray = a.isArray, Janus.webRTCAdapter = a.webRTCAdapter, Janus.httpAPICall = a.httpAPICall, Janus.checkJanusExtension = a.checkJanusExtension, Janus.newWebSocket = a.newWebSocket, Janus.listDevices = function(o, e) { o = typeof o === 'function' ? o : Janus.noop, e == null && (e = { audio: !0, video: !0 }), navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(e).then(function(t) { navigator.mediaDevices.enumerateDevices().then(function(e) { Janus.debug(e), o(e); try { var n; var r = t.getTracks(); for (n in r) { var a = r[n]; a != null && a.stop() } } catch (e) {} }) }).catch(function(e) { Janus.error(e), o([]) }) : (Janus.warn('navigator.mediaDevices unavailable'), o([])) }, Janus.attachMediaStream = function(e, n) { Janus.webRTCAdapter.browserDetails.browser !== 'chrome' || Janus.webRTCAdapter.browserDetails.version >= 43 ? e.srcObject = n : void 0 !== e.src ? e.src = URL.createObjectURL(n) : Janus.error('Error attaching stream to element') }, Janus.reattachMediaStream = function(e, n) { Janus.webRTCAdapter.browserDetails.browser !== 'chrome' || Janus.webRTCAdapter.browserDetails.version >= 43 ? e.srcObject = n.srcObject : void 0 !== e.src ? e.src = n.src : Janus.error('Error reattaching stream to element') }; var t = window.onbeforeunload; window.onbeforeunload = function() { for (var e in Janus.log('Closing window'), Janus.sessions)Janus.sessions[e] !== null && void 0 !== Janus.sessions[e] && Janus.sessions[e].destroyOnUnload && (Janus.log('Destroying session ' + e), Janus.sessions[e].destroy({ asyncRequest: !1 })); t && typeof t === 'function' && t() }, Janus.initDone = !0, e.callback() } }, Janus.isWebrtcSupported = function() { return void 0 !== window.RTCPeerConnection && window.RTCPeerConnection !== null && void 0 !== navigator.getUserMedia && navigator.getUserMedia !== null }, Janus.randomString = function(e) { for (var n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', r = '', a = 0; a < e; a++) { var t = Math.floor(Math.random() * n.length); r += n.substring(t, t + 1) } return r }
