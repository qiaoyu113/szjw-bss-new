function Janus(o) { if (void 0 === Janus.initDone) return o.error('Library not initialized'), {}; if (!Janus.isWebrtcSupported()) return o.error('WebRTC not supported by this browser'), {}; if (Janus.log('Library initialized: ' + Janus.initDone), (o = o || {}).success = typeof o.success === 'function' ? o.success : Janus.noop, o.error = typeof o.error === 'function' ? o.error : Janus.noop, o.destroyed = typeof o.destroyed === 'function' ? o.destroyed : Janus.noop, o.server === null || void 0 === o.server) return o.error('Invalid gateway url'), {}; var s = !1; var c = null; var d = {}; var u = null; var i = null; var l = 0; var p = o.server; Janus.isArray(p) ? (Janus.log('Multiple servers provided (' + p.length + '), will use the first that works'), p = null, i = o.server, Janus.debug(i)) : p.indexOf('ws') === 0 ? (s = !0, Janus.log('Using WebSockets to contact Janus: ' + p)) : (s = !1, Janus.log('Using REST API to contact Janus: ' + p)); var f = o.iceServers; f == null && (f = [{ urls: 'stun:stun.l.google.com:19302' }]); var m = o.iceTransportPolicy; var h = o.bundlePolicy; var v = o.ipv6; v == null && (v = !1); var g = !1; void 0 !== o.withCredentials && o.withCredentials !== null && (g = !0 === o.withCredentials); var t = null; (t = void 0 !== o.max_poll_events && o.max_poll_events !== null ? o.max_poll_events : t) < 1 && (t = 1); var y = null; void 0 !== o.token && o.token !== null && (y = o.token); var b = null; void 0 !== o.apisecret && o.apisecret !== null && (b = o.apisecret), this.destroyOnUnload = !0, void 0 !== o.destroyOnUnload && o.destroyOnUnload !== null && (this.destroyOnUnload = !0 === o.destroyOnUnload); var n; var S = !1; var w = null; var C = {}; var T = this; var J = 0; var R = {}; var r = 0; function P() { var e; w != null && (Janus.debug('Long poll...'), S ? (e = p + '/' + w + '?rid=' + (new Date()).getTime(), t != null && (e = e + '&maxev=' + t), y != null && (e = e + '&token=' + y), b != null && (e = e + '&apisecret=' + b), Janus.httpAPICall(e, { verb: 'GET', withCredentials: g, success: k, timeout: 6e4, error: function(e, t) { if (Janus.error(e + ': ' + t), ++J > 3) { if (r % 60 == 0) return r = 0, void o.error('Lost connection to the gateway (is it down?)'); r++, clearTimeout(n), n = setTimeout(function() { P() }, 1e3) }P() } })) : Janus.warn('Is the gateway down? (connected=false)')) } function k(e, t) { var n, r, a, i; if (J = 0, s || w == null || !0 === t || setTimeout(P, 200), s || !Janus.isArray(e))e.janus === 'keepalive' ? Janus.vdebug('Got a keepalive on session ' + w) : e.janus === 'ack' ? (Janus.debug('Got an ack on session ' + w), Janus.debug(e), (r = e.transaction) != null && ((n = R[r]) != null && n(e), delete R[r])) : e.janus === 'success' ? (Janus.debug('Got a success on session ' + w), Janus.debug(e), (r = e.transaction) != null && ((n = R[r]) != null && n(e), delete R[r])) : e.janus === 'webrtcup' ? (Janus.debug('Got a webrtcup event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (i = C[a]) != null ? i.webrtcState(!0) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'hangup' ? (Janus.debug('Got a hangup event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (i = C[a]) != null ? (i.webrtcState(!1, e.reason), i.hangup()) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'detached' ? (Janus.debug('Got a detached event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (i = C[a]) != null && (i.detached = !0, i.ondetached(), i.detach()) : Janus.warn('Missing sender...')) : e.janus === 'media' ? (Janus.debug('Got a media event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (i = C[a]) != null ? i.mediaState(e.type, e.receiving) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'slowlink' ? (Janus.debug('Got a slowlink event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (i = C[a]) != null ? i.slowLink(e.uplink, e.nacks) : Janus.debug('This handle is not attached to this session') : Janus.warn('Missing sender...')) : e.janus === 'error' ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), Janus.debug(e), (r = e.transaction) != null && ((n = R[r]) != null && n(e), delete R[r])) : e.janus === 'event' ? (Janus.debug('Got a plugin event on session ' + w), Janus.debug(e), (a = e.sender) != null ? (r = e.plugindata) != null ? (Janus.debug('  -- Event is coming from ' + a + ' (' + r.plugin + ')'), r = r.data, Janus.debug(r), (i = C[a]) != null ? ((a = e.jsep) != null && (Janus.debug('Handling SDP as well...'), Janus.debug(a)), (i = i.onmessage) != null ? (Janus.debug('Notifying application...'), i(r, a)) : Janus.debug('No provided notification callback')) : Janus.warn('This handle is not attached to this session')) : Janus.warn('Missing plugindata...') : Janus.warn('Missing sender...')) : (Janus.warn("Unkown message/event  '" + e.janus + "' on session " + w), Janus.debug(e)); else for (var o = 0; o < e.length; o++)k(e[o], !0) } function E() { var e; p !== null && s && S && (u = setTimeout(E, 3e4), e = { janus: 'keepalive', session_id: w, transaction: Janus.randomString(12) }, y != null && (e.token = y), b != null && (e.apisecret = b), c.send(JSON.stringify(e))) } function a(n) { !w && window.localStorage.getItem('rtcSessionId') && (w = window.localStorage.getItem('rtcSessionId'), S = !0), (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop; var e = !0; if (void 0 !== n.asyncRequest && n.asyncRequest !== null && (e = !0 === n.asyncRequest), Janus.log('Destroying session ' + w + ' (async=' + e + ')'), !S) return Janus.warn('Is the gateway down? (connected=false)'), void n.success(); if (w == null) return Janus.warn('No session to destroy'), n.success(), void o.destroyed(); delete Janus.sessions[w]; var t = { janus: 'destroy', transaction: Janus.randomString(12) }; if (y != null && (t.token = y), b != null && (t.apisecret = b), s) { t.session_id = w; function r() { for (var e in d)c.removeEventListener(e, d[e]); c.removeEventListener('message', a), c.removeEventListener('error', i), u && clearTimeout(u) } var a = function(e) { e = JSON.parse(e.data); e.session_id == t.session_id && e.transaction == t.transaction && (r(), n.success(), o.destroyed()) }; var i = function(e) { r(), n.error('Failed to destroy the gateway: Is the gateway down?'), o.destroyed() }; return c.addEventListener('message', a), c.addEventListener('error', i), void c.send(JSON.stringify(t)) }Janus.httpAPICall(p + '/' + w, { verb: 'POST', async: e, withCredentials: g, body: t, success: function(e) { Janus.log('Destroyed session:'), Janus.debug(e), w = null, S = !1, window.localStorage.removeItem('rtcSessionId'), e.janus !== 'success' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), n.success(), o.destroyed() }, error: function(e, t) { Janus.error(e + ': ' + t), w = null, S = !1, localStorage.removeItem('rtcSessionId'), n.success(), o.destroyed() } }) } function D(e, n) { if ((n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop, !S) return Janus.warn('Is the gateway down? (connected=false)'), void n.error('Is the gateway down? (connected=false)'); var t = n.message; var r = n.jsep; var a = Janus.randomString(12); var t = { janus: 'message', body: t, transaction: a }; if (y != null && (t.token = y), b != null && (t.apisecret = b), r != null && (t.jsep = r), Janus.debug('Sending message to plugin (handle=' + e + '):'), Janus.debug(t), s) return t.session_id = w, t.handle_id = e, R[a] = function(e) { if (Janus.debug('Message sent!'), Janus.debug(e), e.janus === 'success') { var t = e.plugindata; if (t == null) return Janus.warn('Request succeeded, but missing plugindata...'), void n.success(); Janus.log('Synchronous transaction successful (' + t.plugin + ')'); t = t.data; return Janus.debug(t), void n.success(t) }e.janus === 'ack' ? n.success() : void 0 !== e.error && e.error !== null ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), n.error(e.error.code + ' ' + e.error.reason)) : (Janus.error('Unknown error'), n.error('Unknown error')) }, void c.send(JSON.stringify(t)); Janus.httpAPICall(p + '/' + w + '/' + e, { verb: 'POST', withCredentials: g, body: t, success: function(e) { if (Janus.debug('Message sent!'), Janus.debug(e), e.janus === 'success') { var t = e.plugindata; if (t == null) return Janus.warn('Request succeeded, but missing plugindata...'), void n.success(); Janus.log('Synchronous transaction successful (' + t.plugin + ')'); t = t.data; return Janus.debug(t), void n.success(t) }e.janus === 'ack' ? n.success() : void 0 !== e.error && e.error !== null ? (Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), n.error(e.error.code + ' ' + e.error.reason)) : (Janus.error('Unknown error'), n.error('Unknown error')) }, error: function(e, t) { Janus.error(e + ': ' + t), n.error(e + ': ' + t) } }) } function x(e, t) { if (console.log('candiadate........', t), t.completed && console.log('candidate error==='), S) { t = { janus: 'trickle', candidate: t, transaction: Janus.randomString(12) }; if (y != null && (t.token = y), b != null && (t.apisecret = b), Janus.vdebug('Sending trickle candidate (handle=' + e + '):'), Janus.vdebug(t), s) return t.session_id = w, t.handle_id = e, void c.send(JSON.stringify(t)); Janus.httpAPICall(p + '/' + w + '/' + e, { verb: 'POST', withCredentials: g, body: t, success: function(e) { Janus.vdebug('Candidate sent!'), Janus.vdebug(e), e.janus !== 'ack' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason) }, error: function(e, t) { Janus.error(e + ': ' + t) } }) } else Janus.warn('Is the gateway down? (connected=false)') } function O(e, t) { (t = t || {}).success = typeof t.success === 'function' ? t.success : Janus.noop, t.error = typeof t.error === 'function' ? t.error : Janus.noop; var n = C[e]; if (n == null || n.webrtcStuff === null || void 0 === n.webrtcStuff) return Janus.warn('Invalid handle'), void t.error('Invalid handle'); e = n.webrtcStuff, n = t.text; if (n == null) return Janus.warn('Invalid text'), void t.error('Invalid text'); Janus.log('Sending string on data channel: ' + n), e.dataChannel.send(n), t.success() } function I(e, t) { (t = t || {}).success = typeof t.success === 'function' ? t.success : Janus.noop, t.error = typeof t.error === 'function' ? t.error : Janus.noop; e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), void t.error('Invalid handle'); e = e.webrtcStuff; if ((e.dtmfSender === null || void 0 === e.dtmfSender) && (void 0 === e.myStream || e.myStream === null || (n = e.myStream.getAudioTracks()) != null && n.length > 0 && (r = n[0], e.dtmfSender = e.pc.createDTMFSender(r), Janus.log('Created DTMF Sender'), e.dtmfSender.ontonechange = function(e) { Janus.debug('Sent DTMF tone: ' + e.tone) }), e.dtmfSender === null || void 0 === e.dtmfSender)) return Janus.warn('Invalid DTMF configuration'), void t.error('Invalid DTMF configuration'); var n = t.dtmf; if (n == null) return Janus.warn('Invalid DTMF parameters'), void t.error('Invalid DTMF parameters'); var r = n.tones; if (r == null) return Janus.warn('Invalid DTMF string'), void t.error('Invalid DTMF string'); t = n.duration; t == null && (t = 500); n = n.gap; n == null && (n = 50), Janus.debug('Sending DTMF string ' + r + ' (duration ' + t + 'ms, gap ' + n + 'ms)'), e.dtmfSender.insertDTMF(r, t, n) } function M(n, r) { (r = r || {}).success = typeof r.success === 'function' ? r.success : Janus.noop, r.error = typeof r.error === 'function' ? r.error : Janus.noop, Janus.warn(r); var e = !0; if (void 0 !== r.asyncRequest && r.asyncRequest !== null && (e = !0 === r.asyncRequest), Janus.log('Destroying handle ' + n + ' (async=' + e + ')'), B(n), C[n].detached) return delete C[n], void r.success(); if (!S) return Janus.warn('Is the gateway down? (connected=false)'), void r.error('Is the gateway down? (connected=false)'); var t = { janus: 'detach', transaction: Janus.randomString(12) }; if (y != null && (t.token = y), b != null && (t.apisecret = b), s) return t.session_id = w, t.handle_id = n, c.send(JSON.stringify(t)), delete C[n], void r.success(); Janus.httpAPICall(p + '/' + w + '/' + n, { verb: 'POST', async: e, withCredentials: g, body: t, success: function(e) { Janus.log('Destroyed handle:'), Janus.debug(e), e.janus !== 'success' && Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), delete C[n], r.success() }, error: function(e, t) { Janus.error(e + ': ' + t), delete C[n], r.success() } }) } function j(r, e, t, a, n) { var i = C[r]; if (i == null || i.webrtcStuff === null || void 0 === i.webrtcStuff) return Janus.warn('Invalid handle'), void a.error('Invalid handle'); var o = i.webrtcStuff; Janus.debug('streamsDone:', n), o.myStream = n; var s = { iceServers: f, iceTransportPolicy: m, bundlePolicy: h }; console.log('pc_config.....................', s); var c = { optional: [{ DtlsSrtpKeyAgreement: !0 }] }; !0 === v && c.optional.push({ googIPv6: !0 }), Janus.webRTCAdapter.browserDetails.browser === 'edge' && (s.bundlePolicy = 'max-bundle'), Janus.log('Creating PeerConnection'), Janus.debug(c), o.pc = new RTCPeerConnection(s, c), Janus.debug(o.pc), o.pc.getStats && (o.volume.value = 0, o.bitrate.value = '0 kbits/sec'), Janus.log('Preparing local SDP and gathering candidates (trickle=' + o.trickle + ')'), o.pc.oniceconnectionstatechange = function(e) { console.log('oniceconnectionstatechange......', o.pc.iceConnectionState), o.pc && i.iceState(o.pc.iceConnectionState) }, o.pc.onicecandidate = function(e) { var t, n; e.candidate == null || Janus.webRTCAdapter.browserDetails.browser === 'edge' && e.candidate.candidate.indexOf('endOfCandidates') > 0 ? (Janus.log('End of candidates.'), (o.iceDone = !0) === o.trickle ? x(r, { completed: !0 }) : (t = r, (n = (n = a) || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop, (t = C[t]) == null || t.webrtcStuff === null || void 0 === t.webrtcStuff ? Janus.warn('Invalid handle, not sending anything') : (t = t.webrtcStuff, Janus.log('Sending offer/answer SDP...'), t.mySdp === null || void 0 === t.mySdp ? Janus.warn('Local SDP instance is invalid, not sending anything...') : (t.mySdp = { type: t.pc.localDescription.type, sdp: t.pc.localDescription.sdp }, t.sdpSent ? Janus.log('Offer/Answer SDP already sent, not sending it again') : (!1 === t.trickle && (t.mySdp.trickle = !1), Janus.debug(n), t.sdpSent = !0, n.success(t.mySdp)))))) : (e = { candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex }, !0 === o.trickle && x(r, e)) }, n != null && (Janus.log('Adding local stream'), n.getTracks().forEach(e => o.pc.addTrack(e, n)), i.onlocalstream(n)), o.pc.ontrack = function(e) { Janus.log('Handling Remote Track'), Janus.debug(e), e.streams && (o.remoteStream = e.streams[0], i.onremotestream(o.remoteStream)) }, c = t, Janus.debug('isDataEnabled:', c), (Janus.webRTCAdapter.browserDetails.browser != 'edge' ? c == null || !0 !== c.data : (Janus.warn("Edge doesn't support data channels yet"), 1)) || (Janus.log('Creating data channel'), c = function() { var e = o.dataChannel !== null ? o.dataChannel.readyState : 'null'; Janus.log('State change on data channel: ' + e), e === 'open' && i.ondataopen() }, o.dataChannel = o.pc.createDataChannel('JanusDataChannel', { ordered: !1 }), o.dataChannel.onmessage = function(e) { Janus.log('Received message on data channel: ' + e.data), i.ondata(e.data) }, o.dataChannel.onopen = c, o.dataChannel.onclose = c, o.dataChannel.onerror = function(e) { Janus.error('Got error on data channel:', e) }), e == null ? A(r, t, a) : o.pc.setRemoteDescription(new RTCSessionDescription(e), function() { Janus.log('Remote description accepted!'), N(r, t, a) }, a.error) } function _(o, s) { (s = s || {}).success = typeof s.success === 'function' ? s.success : Janus.noop, s.error = typeof s.error === 'function' ? s.error : W; var c = s.jsep; var d = s.media; var u = C[o]; if (u == null || u.webrtcStuff === null || void 0 === u.webrtcStuff) return Janus.warn('Invalid handle'), void s.error('Invalid handle'); var e; var t = u.webrtcStuff; if (void 0 !== t.pc && t.pc !== null) return Janus.log('Updating existing media session'), void (c == null ? A(o, d, s) : t.pc.setRemoteDescription(new RTCSessionDescription(c), function() { Janus.log('Remote description accepted!'), N(o, d, s) }, s.error)); if (t.trickle = (e = s.trickle, Janus.debug('isTrickleEnabled:', e), e == null || !0 === e), s.stream !== null && void 0 !== s.stream) { var n = s.stream; return Janus.log('MediaStream provided by the application'), Janus.debug(n), t.streamExternal = !0, void j(o, c, d, s, n) } if (q(d) || H(d)) { var r = { mandatory: {}, optional: [] }; u.consentDialog(!0), !0 === q(d) && d != null && d != null && typeof d.audio === 'object' && d.audio; var l = H(d); if (!0 === l && d != null && d != null) if (!(!0 === s.simulcast) || c || void 0 !== d.video && !1 !== d.video || (d.video = 'hires'), d.video && d.video != 'screen' && d.video != 'window') { var a = 0; var i = 0; var n = 0; d.video === 'lowres' ? (n = i = 240, a = 320) : d.video === 'lowres-16:9' ? (n = i = 180, a = 320) : d.video === 'hires' || d.video === 'hires-16:9' ? (n = i = 720, a = 1280, navigator.mozGetUserMedia && parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) < 38 && (Janus.warn(d.video + ' unsupported, falling back to stdres (old Firefox)'), n = i = 480, a = 640)) : a = (n = i = d.video === 'stdres' ? 480 : d.video === 'stdres-16:9' ? 360 : (Janus.log('Default video setting is stdres 4:3'), 480), 640), Janus.log('Adding media constraint:', d.video), l = navigator.mozGetUserMedia ? parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) < 38 ? { require: ['height', 'width'], height: { max: n, min: i }, width: { max: a, min: a } } : { height: { ideal: i }, width: { ideal: a } } : { mandatory: { maxHeight: n, minHeight: i, maxWidth: a, minWidth: a }, optional: [] }, typeof d.video === 'object' && (l = d.video), Janus.debug(l) } else if (d.video === 'screen' || d.video === 'window') { if (d.screenshareFrameRate || (d.screenshareFrameRate = 3), window.location.protocol !== 'https:') return Janus.warn('Screen sharing only works on HTTPS, try the https:// version of this page'), u.consentDialog(!1), void s.error('Screen sharing only works on HTTPS, try the https:// version of this page'); var p = {}; function f(e, t) { u.consentDialog(!1), e ? s.error({ code: e.code, name: e.name, message: e.message }) : j(o, c, d, s, t) } function m(e, n, r) { Janus.log('Adding media constraint (screen capture)'), Janus.debug(e), navigator.mediaDevices.getUserMedia(e).then(function(t) { r ? navigator.mediaDevices.getUserMedia({ audio: !0, video: !1 }).then(function(e) { t.addTrack(e.getAudioTracks()[0]), n(null, t) }) : n(null, t) }).catch(function(e) { u.consentDialog(!1), n(e) }) } if (Janus.webRTCAdapter.browserDetails.browser === 'chrome') { i = Janus.webRTCAdapter.browserDetails.version, a = 33; window.navigator.userAgent.match('Linux') && (a = 35), i >= 26 && i <= a ? m(r = { video: { mandatory: { googLeakyBucket: !0, maxWidth: window.screen.width, maxHeight: window.screen.height, minFrameRate: d.screenshareFrameRate, maxFrameRate: d.screenshareFrameRate, chromeMediaSource: 'screen' } }, audio: q(d) }, f) : (a = window.setTimeout(function() { return (h = new Error('NavigatorUserMediaError')).name = 'The required Chrome extension is not installed: click <a href="#">here</a> to install it. (NOTE: this will need you to refresh the page)', u.consentDialog(!1), s.error(h) }, 1e3), p[a] = [f, null], window.postMessage({ type: 'janusGetScreen', id: a }, '*')) } else if (window.navigator.userAgent.match('Firefox')) { if (!(parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) >= 33)) { var h = new Error('NavigatorUserMediaError'); return h.name = 'Your version of Firefox does not support screen sharing, please install Firefox 33 (or more recent versions)', u.consentDialog(!1), void s.error(h) }m(r = { video: { mozMediaSource: d.video, mediaSource: d.video }, audio: q(d) }, function(e, t) { var n, r; f(e, t), e || (n = t.currentTime, r = window.setInterval(function() { t || window.clearInterval(r), t.currentTime == n && (window.clearInterval(r), t.onended && t.onended()), n = t.currentTime }, 500)) }) } return void window.addEventListener('message', function(e) { var t, n; e.origin == window.location.origin && (e.data.type == 'janusGotScreen' && p[e.data.id] ? (t = p[e.data.id][0], delete p[e.data.id], e.data.sourceId === '' ? ((n = new Error('NavigatorUserMediaError')).name = 'You cancelled the request for permission, giving up...', u.consentDialog(!1), s.error(n)) : ((r = { audio: !1, video: { mandatory: { chromeMediaSource: 'desktop', maxWidth: window.screen.width, maxHeight: window.screen.height, minFrameRate: d.screenshareFrameRate, maxFrameRate: d.screenshareFrameRate }, optional: [{ googLeakyBucket: !0 }, { googTemporalLayeredScreencast: !0 }] } }).video.mandatory.chromeMediaSourceId = e.data.sourceId, m(r, t, q(d)))) : e.data.type == 'janusGetScreenPending' && window.clearTimeout(e.data.id)) }) }d != null && d.video === 'screen' || navigator.mediaDevices.enumerateDevices().then(function(e) { var t; var n = e.some(function(e) { return e.kind === 'audioinput' }); var r = e.some(function(e) { return e.kind === 'videoinput' }); var a = q(d); var i = H(d); var e = (t = d, Janus.debug('isAudioSendRequired:', t), t != null && (!1 !== t.audio && !1 !== t.audioSend && (void 0 !== t.failIfNoAudio && t.failIfNoAudio !== null && !0 === t.failIfNoAudio))); var t = (t = d, Janus.debug('isVideoSendRequired:', t), t != null && (!1 !== t.video && !1 !== t.videoSend && (void 0 !== t.failIfNoVideo && t.failIfNoVideo !== null && !0 === t.failIfNoVideo))); if (a || i || e || t) { n = !!a && n, i = !!i && r; if (!n && !i) return u.consentDialog(!1), s.error('No capture device found'), !1; if (!n && e) return u.consentDialog(!1), s.error('Audio capture is required, but no capture device found'), !1; if (!i && t) return u.consentDialog(!1), s.error('Video capture is required, but no capture device found'), !1 }navigator.mediaDevices.getUserMedia({ audio: d.audio || !1, video: !!r && l }).then(function(e) { u.consentDialog(!1), j(o, c, d, s, e) }).catch(function(e) { u.consentDialog(!1), s.error({ code: e.code, name: e.name, message: e.message }) }) }).catch(function(e) { u.consentDialog(!1), s.error('enumerateDevices error', e) }) } else j(o, c, d, s) } function L(e, t) { (t = t || {}).success = typeof t.success === 'function' ? t.success : Janus.noop, t.error = typeof t.error === 'function' ? t.error : W; var n = t.jsep; var e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), void t.error('Invalid handle'); e = e.webrtcStuff; if (n != null) { if (e.pc === null) return Janus.warn('Wait, no PeerConnection?? if this is an answer, use createAnswer and not handleRemoteJsep'), void t.error('No PeerConnection: if this is an answer, use createAnswer and not handleRemoteJsep'); e.pc.setRemoteDescription(new RTCSessionDescription(n), function() { Janus.log('Remote description accepted!'), t.success() }, t.error) } else t.error('Invalid JSEP') } function A(e, t, n) { (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop; var r = C[e]; if (r == null || r.webrtcStuff === null || void 0 === r.webrtcStuff) return Janus.warn('Invalid handle'), void n.error('Invalid handle'); var a = r.webrtcStuff; var i = !0 === n.simulcast; i ? Janus.log('Creating offer (iceDone=' + a.iceDone + ', simulcast=' + i + ')') : Janus.log('Creating offer (iceDone=' + a.iceDone + ')'); e = null, e = Janus.webRTCAdapter.browserDetails.browser == 'firefox' || Janus.webRTCAdapter.browserDetails.browser == 'edge' ? { offerToReceiveAudio: z(t), offerToReceiveVideo: $(t) } : { mandatory: { OfferToReceiveAudio: z(t), OfferToReceiveVideo: $(t) } }; Janus.debug(e); var o = H(t); o && i && adapter.browserDetails.browser === 'firefox' && (Janus.log('Enabling Simulcasting for Firefox (RID)'), r = a.pc.getSenders()[1], Janus.log(r), t = r.getParameters(), Janus.log(t), r.setParameters({ encodings: [{ rid: 'high', active: !0, priority: 'high', maxBitrate: 1e6 }, { rid: 'medium', active: !0, priority: 'medium', maxBitrate: 3e5 }, { rid: 'low', active: !0, priority: 'low', maxBitrate: 1e5 }] })), a.pc.createOffer(function(e) { Janus.debug(e), a.mySdp !== null && void 0 !== a.mySdp || (Janus.log('Setting local description'), o && i && (adapter.browserDetails.browser === 'chrome' ? (Janus.log('Enabling Simulcasting for Chrome (SDP munging)'), e.sdp = (function(e) { for (var t = e.split('\r\n'), n = !1, r = [-1], a = -1, i = null, o = null, s = null, c = null, d = -1, u = 0; u < t.length; u++) { var l = t[u].match(/m=(\w+) */); if (l) { if (l[1] === 'video') { if (!(r[0] < 0)) { d = u; break }n = !0 } else if (r[0] > -1) { d = u; break } } else if (n) { var p = t[u].match(/a=ssrc-group:FID (\d+) (\d+)/); if (p)r[0] = p[1], a = p[2], t.splice(u, 1), u--; else { if (r[0]) { if ((f = t[u].match('a=ssrc:' + r[0] + ' cname:(.+)')) && (i = f[1]), (f = t[u].match('a=ssrc:' + r[0] + ' msid:(.+)')) && (o = f[1]), (f = t[u].match('a=ssrc:' + r[0] + ' mslabel:(.+)')) && (s = f[1]), (f = t[u].match('a=ssrc:' + r + ' label:(.+)')) && (c = f[1]), t[u].indexOf('a=ssrc:' + a) === 0) { t.splice(u, 1), u--; continue } if (t[u].indexOf('a=ssrc:' + r[0]) === 0) { t.splice(u, 1), u--; continue } }t[u].length != 0 || (t.splice(u, 1), u--) } } } if (r[0] < 0) { n = !(d = -1); for (u = 0; u < t.length; u++) { var f; var l = t[u].match(/m=(\w+) */); if (l) { if (l[1] === 'video') { if (!(r[0] < 0)) { d = u; break }n = !0 } else if (r[0] > -1) { d = u; break } } else if (n) { if (r[0] < 0) { var m = t[u].match(/a=ssrc:(\d+)/); if (m) { r[0] = m[1], t.splice(u, 1), u--; continue } } else { if ((f = t[u].match('a=ssrc:' + r[0] + ' cname:(.+)')) && (i = f[1]), (f = t[u].match('a=ssrc:' + r[0] + ' msid:(.+)')) && (o = f[1]), (f = t[u].match('a=ssrc:' + r[0] + ' mslabel:(.+)')) && (s = f[1]), (f = t[u].match('a=ssrc:' + r + ' label:(.+)')) && (c = f[1]), t[u].indexOf('a=ssrc:' + a) === 0) { t.splice(u, 1), u--; continue } if (t[u].indexOf('a=ssrc:' + r[0]) === 0) { t.splice(u, 1), u--; continue } }t[u].length != 0 || (t.splice(u, 1), u--) } } } if (r[0] < 0) return Janus.warn("Couldn't find the video SSRC, simulcasting NOT enabled"), e; d < 0 && (d = t.length); r[1] = Math.floor(4294967295 * Math.random()), r[2] = Math.floor(4294967295 * Math.random()); for (u = 0; u < r.length; u++)i && (t.splice(d, 0, 'a=ssrc:' + r[u] + ' cname:' + i), d++), o && (t.splice(d, 0, 'a=ssrc:' + r[u] + ' msid:' + o), d++), s && (t.splice(d, 0, 'a=ssrc:' + r[u] + ' mslabel:' + o), d++), c && (t.splice(d, 0, 'a=ssrc:' + r[u] + ' label:' + o), d++); t.splice(d, 0, 'a=ssrc-group:SIM ' + r[0] + ' ' + r[1] + ' ' + r[2]), (e = t.join('\r\n')).endsWith('\r\n') || (e += '\r\n'); return e }(e.sdp))) : adapter.browserDetails.browser !== 'firefox' && Janus.warn('simulcast=true, but this is not Chrome nor Firefox, ignoring')), a.mySdp = e.sdp, a.pc.setLocalDescription(e)), a.iceDone || a.trickle ? a.sdpSent ? Janus.log('Offer already sent, not sending it again') : (Janus.log('Offer ready'), Janus.debug(n), a.sdpSent = !0, e = { type: e.type, sdp: e.sdp }, console.log(e, '媒体信息'), n.success(e)) : Janus.log('Waiting for all candidates...') }, n.error, e) } function N(e, t, n) { (n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop; var r = C[e]; if (r == null || r.webrtcStuff === null || void 0 === r.webrtcStuff) return Janus.warn('Invalid handle'), void n.error('Invalid handle'); var a = r.webrtcStuff; var i = !0 === n.simulcast; i ? Janus.log('Creating answer (iceDone=' + a.iceDone + ', simulcast=' + i + ')') : Janus.log('Creating answer (iceDone=' + a.iceDone + ')'); e = null, e = Janus.webRTCAdapter.browserDetails.browser == 'firefox' || Janus.webRTCAdapter.browserDetails.browser == 'edge' ? { offerToReceiveAudio: z(t), offerToReceiveVideo: $(t) } : { mandatory: { OfferToReceiveAudio: z(t), OfferToReceiveVideo: $(t) } }; Janus.debug(e); var o = H(t); o && i && adapter.browserDetails.browser === 'firefox' && (Janus.log('Enabling Simulcasting for Firefox (RID)'), r = a.pc.getSenders()[1], Janus.log(r), t = r.getParameters(), Janus.log(t), r.setParameters({ encodings: [{ rid: 'high', active: !0, priority: 'high', maxBitrate: 1e6 }, { rid: 'medium', active: !0, priority: 'medium', maxBitrate: 3e5 }, { rid: 'low', active: !0, priority: 'low', maxBitrate: 1e5 }] })), a.pc.createAnswer(function(e) { Janus.debug(e), a.mySdp !== null && void 0 !== a.mySdp || (Janus.log('Setting local description'), o && i && (adapter.browserDetails.browser === 'chrome' ? Janus.warn('simulcast=true, but this is an answer, and video breaks in Chrome if we enable it') : adapter.browserDetails.browser !== 'firefox' && Janus.warn('simulcast=true, but this is not Chrome nor Firefox, ignoring')), a.mySdp = e.sdp, a.pc.setLocalDescription(e)), a.iceDone || a.trickle ? a.sdpSent ? Janus.log('Answer already sent, not sending it again') : (a.sdpSent = !0, e = { type: e.type, sdp: e.sdp }, n.success(e)) : Janus.log('Waiting for all candidates...') }, n.error, e) } function U(e) { e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), 0; var a = e.webrtcStuff; return a.pc.getStats && Janus.webRTCAdapter.browserDetails.browser == 'chrome' ? a.remoteStream === null || void 0 === a.remoteStream ? (Janus.warn('Remote stream unavailable'), 0) : a.volume.timer === null || void 0 === a.volume.timer ? (Janus.log('Starting volume monitor'), a.volume.timer = setInterval(function() { a.pc.getStats(function(e) { for (var t = e.result(), n = 0; n < t.length; n++) { var r = t[n]; r.type == 'ssrc' && r.stat('audioOutputLevel') && (a.volume.value = r.stat('audioOutputLevel')) } }) }, 200), 0) : a.volume.value : (Janus.log('Getting the remote volume unsupported by browser'), 0) } function G(e, t) { e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), !0; e = e.webrtcStuff; return e.pc === null || void 0 === e.pc ? (Janus.warn('Invalid PeerConnection'), !0) : void 0 === e.myStream || e.myStream === null ? (Janus.warn('Invalid local MediaStream'), !0) : t ? e.myStream.getVideoTracks() === null || void 0 === e.myStream.getVideoTracks() || e.myStream.getVideoTracks().length === 0 ? (Janus.warn('No video track'), !0) : !e.myStream.getVideoTracks()[0].enabled : e.myStream.getAudioTracks() === null || void 0 === e.myStream.getAudioTracks() || e.myStream.getAudioTracks().length === 0 ? (Janus.warn('No audio track'), !0) : !e.myStream.getAudioTracks()[0].enabled } function F(e, t, n) { e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), !1; e = e.webrtcStuff; return e.pc === null || void 0 === e.pc ? (Janus.warn('Invalid PeerConnection'), !1) : void 0 === e.myStream || e.myStream === null ? (Janus.warn('Invalid local MediaStream'), !1) : t ? e.myStream.getVideoTracks() === null || void 0 === e.myStream.getVideoTracks() || e.myStream.getVideoTracks().length === 0 ? (Janus.warn('No video track'), !1) : (e.myStream.getVideoTracks()[0].enabled = !n, !0) : e.myStream.getAudioTracks() === null || void 0 === e.myStream.getAudioTracks() || e.myStream.getAudioTracks().length === 0 ? (Janus.warn('No audio track'), !1) : (e.myStream.getAudioTracks()[0].enabled = !n, !0) } function V(e) { e = C[e]; if (e == null || e.webrtcStuff === null || void 0 === e.webrtcStuff) return Janus.warn('Invalid handle'), 'Invalid handle'; var n = e.webrtcStuff; return n.pc === null || void 0 === n.pc ? 'Invalid PeerConnection' : n.pc.getStats ? n.bitrate.timer === null || void 0 === n.bitrate.timer ? (Janus.log('Starting bitrate timer (via getStats)'), n.bitrate.timer = setInterval(function() { n.pc.getStats().then(function(e) { e.forEach(function(e) { var t; e && (t = !1, (t = (e.mediaType === 'video' || e.id.toLowerCase().indexOf('video') > -1) && e.type === 'inbound-rtp' && e.id.indexOf('rtcp') < 0 || e.type == 'ssrc' && e.bytesReceived && (e.googCodecName === 'VP8' || e.googCodecName === '') ? !0 : t) && (n.bitrate.bsnow = e.bytesReceived, n.bitrate.tsnow = e.timestamp, n.bitrate.bsbefore === null || n.bitrate.tsbefore === null || (e = n.bitrate.tsnow - n.bitrate.tsbefore, adapter.browserDetails.browser == 'safari' && (e /= 1e3), e = Math.round(8 * (n.bitrate.bsnow - n.bitrate.bsbefore) / e), n.bitrate.value = e + ' kbits/sec'), n.bitrate.bsbefore = n.bitrate.bsnow, n.bitrate.tsbefore = n.bitrate.tsnow)) }) }) }, 1e3), '0 kbits/sec') : n.bitrate.value : (Janus.warn('Getting the video bitrate unsupported by browser'), 'Feature unsupported by browser') } function W(e) { Janus.error('WebRTC error:', e) } function B(e, t) { Janus.log('Cleaning WebRTC stuff'); var n = C[e]; if (n != null) { var r = n.webrtcStuff; if (r != null) { !0 === t && (t = { janus: 'hangup', transaction: Janus.randomString(12) }, y != null && (t.token = y), b != null && (t.apisecret = b), Janus.debug('Sending hangup request (handle=' + e + '):'), Janus.debug(t), s ? (t.session_id = w, t.handle_id = e, c.send(JSON.stringify(t))) : Janus.httpAPICall(p + '/' + w + '/' + e, { verb: 'POST', withCredentials: g, data: t })), r.remoteStream = null, r.volume.timer && clearInterval(r.volume.timer), r.volume.value = null, r.bitrate.timer && clearInterval(r.bitrate.timer), r.bitrate.timer = null, r.bitrate.bsnow = null, r.bitrate.bsbefore = null, r.bitrate.tsnow = null, r.bitrate.tsbefore = null, r.bitrate.value = null; try { if (!r.streamExternal && r.myStream !== null && void 0 !== r.myStream) { Janus.log('Stopping local stream tracks'); var a; var i = r.myStream.getTracks(); for (a in i) { var o = i[a]; Janus.log(o), o != null && o.stop() } } } catch (e) {}r.streamExternal = !1, r.myStream = null; try { r.pc.close() } catch (e) {}r.pc = null, r.mySdp = null, r.iceDone = !1, r.sdpSent = !1, r.dataChannel = null, r.dtmfSender = null }n.oncleanup() } } function q(e) { return Janus.debug('isAudioSendEnabled:', e), e == null || !1 !== e.audio && (void 0 === e.audioSend || e.audioSend === null || !0 === e.audioSend) } function z(e) { return Janus.debug('isAudioRecvEnabled:', e), e == null || !1 !== e.audio && (void 0 === e.audioRecv || e.audioRecv === null || !0 === e.audioRecv) } function H(e) { return Janus.debug('isVideoSendEnabled:', e), e == null || !1 !== e.video && (void 0 === e.videoSend || e.videoSend === null || !0 === e.videoSend) } function $(e) { return Janus.debug('isVideoRecvEnabled:', e), e == null || !1 !== e.video && (void 0 === e.videoRecv || e.videoRecv === null || !0 === e.videoRecv) }console.log(window.localStorage.getItem('rtcSessionId'), '获取rtcSession'), a({ success: function() { console.log('===============destroySession============'), (function n(r) { var e = Janus.randomString(12); var t = { janus: 'create', transaction: e }; y != null && (t.token = y); b != null && (t.apisecret = b); p === null && Janus.isArray(i) && ((p = i[l]).indexOf('ws') === 0 ? (s = !0, Janus.log('Server #' + (l + 1) + ': trying WebSockets to contact Janus (' + p + ')')) : (s = !1, Janus.log('Server #' + (l + 1) + ': trying REST API to contact Janus (' + p + ')'))); if (s) { for (var a in c = Janus.newWebSocket(p, 'janus-protocol'), d = { error: function() { if (Janus.error('Error connecting to the Janus WebSockets server... ' + p), Janus.isArray(i)) return ++l == i.length ? void r.error('Error connecting to any of the provided Janus servers: Is the gateway down?') : (p = null, void setTimeout(function() { n(r) }, 200)); r.error('Error connecting to the Janus WebSockets server: Is the gateway down?') }, open: function() { R[e] = function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void r.error(e.error.reason); u = setTimeout(E, 3e4), S = !0, w = e.data.id, Janus.log('Created session: ' + w), Janus.sessions[w] = T, r.success() }, c.send(JSON.stringify(t)) }, message: function(e) { k(JSON.parse(e.data)) }, close: function() { p !== null && S && (S = !1, o.error('Lost connection to the gateway (is it down?)')) } })c.addEventListener(a, d[a]); return }Janus.httpAPICall(p, { verb: 'POST', withCredentials: g, body: t, success: function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void r.error(e.error.reason); S = !0, w = e.data.id, Janus.log('Created session: ' + w), Janus.sessions[w] = T, console.log('创建了sessionId'), window.localStorage.setItem('rtcSessionId', w), P(), r.success() }, error: function(e, t) { if (Janus.error(e + ': ' + t), Janus.isArray(i)) return ++l == i.length ? void r.error('Error connecting to any of the provided Janus servers: Is the gateway down?') : (p = null, void setTimeout(function() { n(r) }, 200)); t === '' ? r.error(e + ': Is the gateway down?') : r.error(e + ': ' + t) } }) }(o)) } }), this.getServer = function() { return p }, this.isConnected = function() { return S }, this.getSessionId = function() { return w }, this.destroy = function(e) { a(e) }, this.attach = function(e) { !(function(n) { if ((n = n || {}).success = typeof n.success === 'function' ? n.success : Janus.noop, n.error = typeof n.error === 'function' ? n.error : Janus.noop, n.consentDialog = typeof n.consentDialog === 'function' ? n.consentDialog : Janus.noop, n.iceState = typeof n.iceState === 'function' ? n.iceState : Janus.noop, n.mediaState = typeof n.mediaState === 'function' ? n.mediaState : Janus.noop, n.webrtcState = typeof n.webrtcState === 'function' ? n.webrtcState : Janus.noop, n.slowLink = typeof n.slowLink === 'function' ? n.slowLink : Janus.noop, n.onmessage = typeof n.onmessage === 'function' ? n.onmessage : Janus.noop, n.onlocalstream = typeof n.onlocalstream === 'function' ? n.onlocalstream : Janus.noop, n.onremotestream = typeof n.onremotestream === 'function' ? n.onremotestream : Janus.noop, n.ondata = typeof n.ondata === 'function' ? n.ondata : Janus.noop, n.ondataopen = typeof n.ondataopen === 'function' ? n.ondataopen : Janus.noop, n.oncleanup = typeof n.oncleanup === 'function' ? n.oncleanup : Janus.noop, n.ondetached = typeof n.ondetached === 'function' ? n.ondetached : Janus.noop, !S) return Janus.warn('Is the gateway down? (connected=false)'), n.error('Is the gateway down? (connected=false)'); var r = n.plugin; if (r == null) return Janus.error('Invalid plugin'), n.error('Invalid plugin'); var e = n.opaqueId; var t = Janus.randomString(12); var e = { janus: 'attach', plugin: r, opaque_id: e, transaction: t }; if (y != null && (e.token = y), b != null && (e.apisecret = b), adapter.browserDetails.browser != 'chrome' && adapter.browserDetails.browser != 'firefox' && adapter.browserDetails.browser != 'safari' || (e['force-bundle'] = !0, e['force-rtcp-mux'] = !0), s) return R[t] = function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void n.error('Ooops: ' + e.error.code + ' ' + e.error.reason); var t = e.data.id; Janus.log('Created handle: ' + t); e = { session: T, plugin: r, id: t, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, remoteStream: null, mySdp: null, pc: null, dataChannel: null, dtmfSender: null, trickle: !0, iceDone: !1, sdpSent: !1, volume: { value: null, timer: null }, bitrate: { value: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, timer: null } }, getId: function() { return t }, getPlugin: function() { return r }, getVolume: function() { return U(t) }, isAudioMuted: function() { return G(t, !1) }, muteAudio: function() { return F(t, !1, !0) }, unmuteAudio: function() { return F(t, !1, !1) }, isVideoMuted: function() { return G(t, !0) }, muteVideo: function() { return F(t, !0, !0) }, unmuteVideo: function() { return F(t, !0, !1) }, getBitrate: function() { return V(t) }, send: function(e) { D(t, e) }, data: function(e) { O(t, e) }, dtmf: function(e) { I(t, e) }, consentDialog: n.consentDialog, iceState: n.iceState, mediaState: n.mediaState, webrtcState: n.webrtcState, slowLink: n.slowLink, onmessage: n.onmessage, createOffer: function(e) { _(t, e) }, createAnswer: function(e) { _(t, e) }, handleRemoteJsep: function(e) { L(t, e) }, onlocalstream: n.onlocalstream, onremotestream: n.onremotestream, ondata: n.ondata, ondataopen: n.ondataopen, oncleanup: n.oncleanup, ondetached: n.ondetached, hangup: function(e) { B(t, !0 === e) }, detach: function(e) { M(t, e) } }; C[t] = e, n.success(e) }, e.session_id = w, c.send(JSON.stringify(e)); Janus.httpAPICall(p + '/' + w, { verb: 'POST', withCredentials: g, body: e, success: function(e) { if (Janus.debug(e), e.janus !== 'success') return Janus.error('Ooops: ' + e.error.code + ' ' + e.error.reason), void n.error('Ooops: ' + e.error.code + ' ' + e.error.reason); var t = e.data.id; Janus.log('Created handle: ' + t); e = { session: T, plugin: r, id: t, detached: !1, webrtcStuff: { started: !1, myStream: null, streamExternal: !1, remoteStream: null, mySdp: null, pc: null, dataChannel: null, dtmfSender: null, trickle: !0, iceDone: !1, sdpSent: !1, volume: { value: null, timer: null }, bitrate: { value: null, bsnow: null, bsbefore: null, tsnow: null, tsbefore: null, timer: null } }, getId: function() { return t }, getPlugin: function() { return r }, getVolume: function() { return U(t) }, isAudioMuted: function() { return G(t, !1) }, muteAudio: function() { return F(t, !1, !0) }, unmuteAudio: function() { return F(t, !1, !1) }, isVideoMuted: function() { return G(t, !0) }, muteVideo: function() { return F(t, !0, !0) }, unmuteVideo: function() { return F(t, !0, !1) }, getBitrate: function() { return V(t) }, send: function(e) { D(t, e) }, data: function(e) { O(t, e) }, dtmf: function(e) { I(t, e) }, consentDialog: n.consentDialog, iceState: n.iceState, mediaState: n.mediaState, webrtcState: n.webrtcState, slowLink: n.slowLink, onmessage: n.onmessage, createOffer: function(e) { _(t, e) }, createAnswer: function(e) { _(t, e) }, handleRemoteJsep: function(e) { L(t, e) }, onlocalstream: n.onlocalstream, onremotestream: n.onremotestream, ondata: n.ondata, ondataopen: n.ondataopen, oncleanup: n.oncleanup, ondetached: n.ondetached, hangup: function(e) { B(t, !0 === e) }, detach: function(e) { M(t, e) } }; C[t] = e, n.success(e) }, error: function(e, t) { Janus.error(e + ': ' + t) } }) }(e)) } }!(function(e) { 'use strict'; function l(e, t) { var n = (65535 & e) + (65535 & t); return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n } function s(e, t, n, r, a, i) { return l((i = l(l(t, e), l(r, i))) << (a = a) | i >>> 32 - a, n) } function p(e, t, n, r, a, i, o) { return s(t & n | ~t & r, e, t, a, i, o) } function f(e, t, n, r, a, i, o) { return s(t & r | n & ~r, e, t, a, i, o) } function m(e, t, n, r, a, i, o) { return s(t ^ n ^ r, e, t, a, i, o) } function h(e, t, n, r, a, i, o) { return s(n ^ (t | ~r), e, t, a, i, o) } function o(e, t) { e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t; for (var n, r, a, i, o = 1732584193, s = -271733879, c = -1732584194, d = 271733878, u = 0; u < e.length; u += 16)o = p(n = o, r = s, a = c, i = d, e[u], 7, -680876936), d = p(d, o, s, c, e[u + 1], 12, -389564586), c = p(c, d, o, s, e[u + 2], 17, 606105819), s = p(s, c, d, o, e[u + 3], 22, -1044525330), o = p(o, s, c, d, e[u + 4], 7, -176418897), d = p(d, o, s, c, e[u + 5], 12, 1200080426), c = p(c, d, o, s, e[u + 6], 17, -1473231341), s = p(s, c, d, o, e[u + 7], 22, -45705983), o = p(o, s, c, d, e[u + 8], 7, 1770035416), d = p(d, o, s, c, e[u + 9], 12, -1958414417), c = p(c, d, o, s, e[u + 10], 17, -42063), s = p(s, c, d, o, e[u + 11], 22, -1990404162), o = p(o, s, c, d, e[u + 12], 7, 1804603682), d = p(d, o, s, c, e[u + 13], 12, -40341101), c = p(c, d, o, s, e[u + 14], 17, -1502002290), o = f(o, s = p(s, c, d, o, e[u + 15], 22, 1236535329), c, d, e[u + 1], 5, -165796510), d = f(d, o, s, c, e[u + 6], 9, -1069501632), c = f(c, d, o, s, e[u + 11], 14, 643717713), s = f(s, c, d, o, e[u], 20, -373897302), o = f(o, s, c, d, e[u + 5], 5, -701558691), d = f(d, o, s, c, e[u + 10], 9, 38016083), c = f(c, d, o, s, e[u + 15], 14, -660478335), s = f(s, c, d, o, e[u + 4], 20, -405537848), o = f(o, s, c, d, e[u + 9], 5, 568446438), d = f(d, o, s, c, e[u + 14], 9, -1019803690), c = f(c, d, o, s, e[u + 3], 14, -187363961), s = f(s, c, d, o, e[u + 8], 20, 1163531501), o = f(o, s, c, d, e[u + 13], 5, -1444681467), d = f(d, o, s, c, e[u + 2], 9, -51403784), c = f(c, d, o, s, e[u + 7], 14, 1735328473), o = m(o, s = f(s, c, d, o, e[u + 12], 20, -1926607734), c, d, e[u + 5], 4, -378558), d = m(d, o, s, c, e[u + 8], 11, -2022574463), c = m(c, d, o, s, e[u + 11], 16, 1839030562), s = m(s, c, d, o, e[u + 14], 23, -35309556), o = m(o, s, c, d, e[u + 1], 4, -1530992060), d = m(d, o, s, c, e[u + 4], 11, 1272893353), c = m(c, d, o, s, e[u + 7], 16, -155497632), s = m(s, c, d, o, e[u + 10], 23, -1094730640), o = m(o, s, c, d, e[u + 13], 4, 681279174), d = m(d, o, s, c, e[u], 11, -358537222), c = m(c, d, o, s, e[u + 3], 16, -722521979), s = m(s, c, d, o, e[u + 6], 23, 76029189), o = m(o, s, c, d, e[u + 9], 4, -640364487), d = m(d, o, s, c, e[u + 12], 11, -421815835), c = m(c, d, o, s, e[u + 15], 16, 530742520), o = h(o, s = m(s, c, d, o, e[u + 2], 23, -995338651), c, d, e[u], 6, -198630844), d = h(d, o, s, c, e[u + 7], 10, 1126891415), c = h(c, d, o, s, e[u + 14], 15, -1416354905), s = h(s, c, d, o, e[u + 5], 21, -57434055), o = h(o, s, c, d, e[u + 12], 6, 1700485571), d = h(d, o, s, c, e[u + 3], 10, -1894986606), c = h(c, d, o, s, e[u + 10], 15, -1051523), s = h(s, c, d, o, e[u + 1], 21, -2054922799), o = h(o, s, c, d, e[u + 8], 6, 1873313359), d = h(d, o, s, c, e[u + 15], 10, -30611744), c = h(c, d, o, s, e[u + 6], 15, -1560198380), s = h(s, c, d, o, e[u + 13], 21, 1309151649), o = h(o, s, c, d, e[u + 4], 6, -145523070), d = h(d, o, s, c, e[u + 11], 10, -1120210379), c = h(c, d, o, s, e[u + 2], 15, 718787259), s = h(s, c, d, o, e[u + 9], 21, -343485551), o = l(o, n), s = l(s, r), c = l(c, a), d = l(d, i); return [o, s, c, d] } function c(e) { for (var t = '', n = 32 * e.length, r = 0; r < n; r += 8)t += String.fromCharCode(e[r >> 5] >>> r % 32 & 255); return t } function d(e) { var t = []; for (t[(e.length >> 2) - 1] = void 0, r = 0; r < t.length; r += 1)t[r] = 0; for (var n = 8 * e.length, r = 0; r < n; r += 8)t[r >> 5] |= (255 & e.charCodeAt(r / 8)) << r % 32; return t } function r(e) { for (var t, n = '0123456789abcdef', r = '', a = 0; a < e.length; a += 1)t = e.charCodeAt(a), r += n.charAt(t >>> 4 & 15) + n.charAt(15 & t); return r } function n(e) { return unescape(encodeURIComponent(e)) } function a(e) { return c(o(d(e = n(e)), 8 * e.length)) } function i(e, t) { return (function(e, t) { var n; var r = d(e); var a = []; var i = []; for (a[15] = i[15] = void 0, r.length > 16 && (r = o(r, 8 * e.length)), n = 0; n < 16; n += 1)a[n] = 909522486 ^ r[n], i[n] = 1549556828 ^ r[n]; return t = o(a.concat(d(t)), 512 + 8 * t.length), c(o(i.concat(t), 640)) }(n(e), n(t))) } function t(e, t, n) { return t ? n ? i(t, e) : r(i(t, e)) : n ? a(e) : r(a(e)) } typeof define === 'function' && define.amd ? define(function() { return t }) : typeof module === 'object' && module.exports ? module.exports = t : e.md5 = t }(this)), (function($) { 'use strict'; var escape = /["\\\x00-\x1f\x7f-\x9f]/g; var meta = { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"': '\\"', '\\': '\\\\' }; var hasOwn = Object.prototype.hasOwnProperty; $.toJSON = typeof JSON === 'object' && JSON.stringify ? JSON.stringify : function(e) { if (e === null) return 'null'; var t; var n; var r; var a; var i = $.type(e); if (i !== 'undefined') { if (i === 'number' || i === 'boolean') return String(e); if (i === 'string') return $.quoteString(e); if (typeof e.toJSON === 'function') return $.toJSON(e.toJSON()); if (i === 'date') { var o = e.getUTCMonth() + 1; var s = e.getUTCDate(); var c = e.getUTCFullYear(); var d = e.getUTCHours(); var u = e.getUTCMinutes(); var l = e.getUTCSeconds(); var p = e.getUTCMilliseconds(); return '"' + c + '-' + (o = o < 10 ? '0' + o : o) + '-' + (s = s < 10 ? '0' + s : s) + 'T' + (d = d < 10 ? '0' + d : d) + ':' + (u = u < 10 ? '0' + u : u) + ':' + (l = l < 10 ? '0' + l : l) + '.' + (p = (p = p < 100 ? '0' + p : p) < 10 ? '0' + p : p) + 'Z"' } if (t = [], $.isArray(e)) { for (n = 0; n < e.length; n++)t.push($.toJSON(e[n]) || 'null'); return '[' + t.join(',') + ']' } if (typeof e === 'object') { for (n in e) if (hasOwn.call(e, n)) { if ((i = typeof n) === 'number')r = '"' + n + '"'; else { if (i !== 'string') continue; r = $.quoteString(n) }(i = typeof e[n]) !== 'function' && i !== 'undefined' && (a = $.toJSON(e[n]), t.push(r + ':' + a)) } return '{' + t.join(',') + '}' } } }, $.evalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function(str) { return eval('(' + str + ')') }, $.secureEvalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function(str) { var filtered = str.replace(/\\["\\\/bfnrtu]/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''); if (/^[\],:{}\s]*$/.test(filtered)) return eval('(' + str + ')'); throw new SyntaxError('Error parsing JSON, source is not valid.') }, $.quoteString = function(e) { return e.match(escape) ? '"' + e.replace(escape, function(e) { var t = meta[e]; return typeof t === 'string' ? t : (t = e.charCodeAt(), '\\u00' + Math.floor(t / 16).toString(16) + (t % 16).toString(16)) }) + '"' : '"' + e + '"' } }(jQuery)), (function(e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define([], e) : (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).adapter = e() }(function() { return (function r(a, i, o) { function s(t, e) { if (!i[t]) { if (!a[t]) { var n = typeof require === 'function' && require; if (!e && n) return n(t, !0); if (c) return c(t, !0); n = new Error("Cannot find module '" + t + "'"); throw n.code = 'MODULE_NOT_FOUND', n }n = i[t] = { exports: {} }; a[t][0].call(n.exports, function(e) { return s(a[t][1][e] || e) }, n, n.exports, r, a, i, o) } return i[t].exports } for (var c = typeof require === 'function' && require, e = 0; e < o.length; e++)s(o[e]); return s }({ 1: [function(e, t, n) { 'use strict'; function s(e, t, n, r) { t = x.writeRtpDescription(e.kind, t); return t += x.writeIceParameters(e.iceGatherer.getLocalParameters()), t += x.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), n === 'offer' ? 'actpass' : 'active'), t += 'a=mid:' + e.mid + '\r\n', e.direction ? t += 'a=' + e.direction + '\r\n' : e.rtpSender && e.rtpReceiver ? t += 'a=sendrecv\r\n' : e.rtpSender ? t += 'a=sendonly\r\n' : e.rtpReceiver ? t += 'a=recvonly\r\n' : t += 'a=inactive\r\n', e.rtpSender && (t += 'a=' + (r = 'msid:' + r.id + ' ' + e.rtpSender.track.id + '\r\n'), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + r, e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + r, t += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n')), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + x.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + x.localCName + '\r\n'), t } function p(r, a) { function i(e, t) { e = parseInt(e, 10); for (var n = 0; n < t.length; n++) if (t[n].payloadType === e || t[n].preferredPayloadType === e) return t[n] } var o = { codecs: [], headerExtensions: [], fecMechanisms: [] }; return r.codecs.forEach(function(n) { for (var e = 0; e < a.codecs.length; e++) { var t = a.codecs[e]; if (n.name.toLowerCase() === t.name.toLowerCase() && n.clockRate === t.clockRate && (n.name.toLowerCase() !== 'rtx' || !n.parameters || !t.parameters.apt || (function(e, t, n, r) { n = i(e.parameters.apt, n), r = i(t.parameters.apt, r); return n && r && n.name.toLowerCase() === r.name.toLowerCase() }(n, t, r.codecs, a.codecs)))) { (t = JSON.parse(JSON.stringify(t))).numChannels = Math.min(n.numChannels, t.numChannels), o.codecs.push(t), t.rtcpFeedback = t.rtcpFeedback.filter(function(e) { for (var t = 0; t < n.rtcpFeedback.length; t++) if (n.rtcpFeedback[t].type === e.type && n.rtcpFeedback[t].parameter === e.parameter) return !0; return !1 }); break } } }), r.headerExtensions.forEach(function(e) { for (var t = 0; t < a.headerExtensions.length; t++) { var n = a.headerExtensions[t]; if (e.uri === n.uri) { o.headerExtensions.push(n); break } } }), o } function i(e, t, n) { return { offer: { setLocalDescription: ['stable', 'have-local-offer'], setRemoteDescription: ['stable', 'have-remote-offer'] }, answer: { setLocalDescription: ['have-remote-offer', 'have-local-pranswer'], setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'] } }[t][e].indexOf(n) !== -1 } function D(e, t) { e.getRemoteCandidates().find(function(e) { return t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type }) || e.addRemoteCandidate(t) } var x = e('sdp'); t.exports = function(k, E) { function e(e) { var r; var a; var t = this; var n = document.createDocumentFragment(); if (['addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(function(e) { t[e] = n[e].bind(n) }), this.onicecandidate = null, this.onaddstream = null, this.ontrack = null, this.onremovestream = null, this.onsignalingstatechange = null, this.oniceconnectionstatechange = null, this.onicegatheringstatechange = null, this.onnegotiationneeded = null, this.ondatachannel = null, this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this.localDescription = null, this.remoteDescription = null, this.signalingState = 'stable', this.iceConnectionState = 'new', this.iceGatheringState = 'new', e = JSON.parse(JSON.stringify(e || {})), this.usingBundle = e.bundlePolicy === 'max-bundle', e.rtcpMuxPolicy === 'negotiate') { var i = new Error("rtcpMuxPolicy 'negotiate' is not supported"); throw i.name = 'NotSupportedError', i } switch (e.rtcpMuxPolicy || (e.rtcpMuxPolicy = 'require'), e.iceTransportPolicy) { case 'all':case 'relay':break; default:e.iceTransportPolicy = 'all' } switch (e.bundlePolicy) { case 'balanced':case 'max-compat':case 'max-bundle':break; default:e.bundlePolicy = 'balanced' } if (e.iceServers = (i = e.iceServers || [], r = E, a = !1, (i = JSON.parse(JSON.stringify(i))).filter(function(e) { if (e && (e.urls || e.url)) { var t = e.urls || e.url; e.url && !e.urls && console.warn('RTCIceServer.url is deprecated! Use urls instead.'); var n = typeof t === 'string'; var t = (t = n ? [t] : t).filter(function(e) { return e.indexOf('turn:') !== 0 || e.indexOf('transport=udp') === -1 || e.indexOf('turn:[') !== -1 || a ? e.indexOf('stun:') === 0 && r >= 14393 && e.indexOf('?transport=udp') === -1 : a = !0 }); return delete e.url, e.urls = n ? t[0] : t, !!t.length } return !1 })), this._iceGatherers = [], e.iceCandidatePoolSize) for (var o = e.iceCandidatePoolSize; o > 0; o--) this._iceGatherers = new k.RTCIceGatherer({ iceServers: e.iceServers, gatherPolicy: e.iceTransportPolicy }); else e.iceCandidatePoolSize = 0; this._config = e, this.transceivers = [], this._sdpSessionId = x.generateSessionId(), this._sdpSessionVersion = 0 } return e.prototype._emitGatheringStateChange = function() { var e = new Event('icegatheringstatechange'); this.dispatchEvent(e), this.onicegatheringstatechange !== null && this.onicegatheringstatechange(e) }, e.prototype.getConfiguration = function() { return this._config }, e.prototype.getLocalStreams = function() { return this.localStreams }, e.prototype.getRemoteStreams = function() { return this.remoteStreams }, e.prototype._createTransceiver = function(e) { var t = this.transceivers.length > 0; var e = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, wantReceive: !0 }; return this.usingBundle && t ? (e.iceTransport = this.transceivers[0].iceTransport, e.dtlsTransport = this.transceivers[0].dtlsTransport) : (t = this._createIceAndDtlsTransports(), e.iceTransport = t.iceTransport, e.dtlsTransport = t.dtlsTransport), this.transceivers.push(e), e }, e.prototype.addTrack = function(e, t) { for (var n, r = 0; r < this.transceivers.length; r++) this.transceivers[r].track || this.transceivers[r].kind !== e.kind || (n = this.transceivers[r]); return n = n || this._createTransceiver(e.kind), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(t) === -1 && this.localStreams.push(t), n.track = e, n.stream = t, n.rtpSender = new k.RTCRtpSender(e, n.dtlsTransport), n.rtpSender }, e.prototype.addStream = function(t) { var r; var n = this; E >= 15025 ? t.getTracks().forEach(function(e) { n.addTrack(e, t) }) : (r = t.clone(), t.getTracks().forEach(function(e, t) { var n = r.getTracks()[t]; e.addEventListener('enabled', function(e) { n.enabled = e.enabled }) }), r.getTracks().forEach(function(e) { n.addTrack(e, r) })) }, e.prototype.removeStream = function(e) { e = this.localStreams.indexOf(e); e > -1 && (this.localStreams.splice(e, 1), this._maybeFireNegotiationNeeded()) }, e.prototype.getSenders = function() { return this.transceivers.filter(function(e) { return !!e.rtpSender }).map(function(e) { return e.rtpSender }) }, e.prototype.getReceivers = function() { return this.transceivers.filter(function(e) { return !!e.rtpReceiver }).map(function(e) { return e.rtpReceiver }) }, e.prototype._createIceGatherer = function(n, e) { var r = this; if (e && n > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var a = new k.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(a, 'state', { value: 'new', writable: !0 }), this.transceivers[n].candidates = [], this.transceivers[n].bufferCandidates = function(e) { var t = !e.candidate || Object.keys(e.candidate).length === 0; a.state = t ? 'completed' : 'gathering', r.transceivers[n].candidates !== null && r.transceivers[n].candidates.push(e.candidate) }, a.addEventListener('localcandidate', this.transceivers[n].bufferCandidates), a }, e.prototype._gather = function(r, a) { var e; var i = this; var o = this.transceivers[a].iceGatherer; o.onlocalcandidate || (e = this.transceivers[a].candidates, this.transceivers[a].candidates = null, o.removeEventListener('localcandidate', this.transceivers[a].bufferCandidates), o.onlocalcandidate = function(e) { var t, n; i.usingBundle && a > 0 || ((t = new Event('icecandidate')).candidate = { sdpMid: r, sdpMLineIndex: a }, (e = !(n = e.candidate) || Object.keys(n).length === 0) ? o.state !== 'new' && o.state !== 'gathering' || (o.state = 'completed') : (o.state === 'new' && (o.state = 'gathering'), n.component = 1, t.candidate.candidate = x.writeCandidate(n)), (n = x.splitSections(i.localDescription.sdp))[t.candidate.sdpMLineIndex + 1] += e ? 'a=end-of-candidates\r\n' : 'a=' + t.candidate.candidate + '\r\n', i.localDescription.sdp = n.join(''), n = i.transceivers.every(function(e) { return e.iceGatherer && e.iceGatherer.state === 'completed' }), i.iceGatheringState !== 'gathering' && (i.iceGatheringState = 'gathering', i._emitGatheringStateChange()), e || (i.dispatchEvent(t), i.onicecandidate !== null && i.onicecandidate(t)), n && (i.dispatchEvent(new Event('icecandidate')), i.onicecandidate !== null && i.onicecandidate(new Event('icecandidate')), i.iceGatheringState = 'complete', i._emitGatheringStateChange())) }, k.setTimeout(function() { e.forEach(function(e) { var t = new Event('RTCIceGatherEvent'); t.candidate = e, o.onlocalcandidate(t) }) }, 0)) }, e.prototype._createIceAndDtlsTransports = function() { var e = this; var t = new k.RTCIceTransport(null); t.onicestatechange = function() { e._updateConnectionState() }; var n = new k.RTCDtlsTransport(t); return n.ondtlsstatechange = function() { e._updateConnectionState() }, n.onerror = function() { Object.defineProperty(n, 'state', { value: 'failed', writable: !0 }), e._updateConnectionState() }, { iceTransport: t, dtlsTransport: n } }, e.prototype._disposeIceAndDtlsTransports = function(e) { var t = this.transceivers[e].iceGatherer; t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer); t = this.transceivers[e].iceTransport; t && (delete t.onicestatechange, delete this.transceivers[e].iceTransport); t = this.transceivers[e].dtlsTransport; t && (delete t.ondtlsstatechange, delete t.onerror, delete this.transceivers[e].dtlsTransport) }, e.prototype._transceive = function(e, t, n) { var r = p(e.localCapabilities, e.remoteCapabilities); t && e.rtpSender && (r.encodings = e.sendEncodingParameters, r.rtcp = { cname: x.localCName, compound: e.rtcpParameters.compound }, e.recvEncodingParameters.length && (r.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(r)), n && e.rtpReceiver && (e.kind === 'video' && e.recvEncodingParameters && E < 15019 && e.recvEncodingParameters.forEach(function(e) { delete e.rtx }), r.encodings = e.recvEncodingParameters, r.rtcp = { cname: e.rtcpParameters.cname, compound: e.rtcpParameters.compound }, e.sendEncodingParameters.length && (r.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(r)) }, e.prototype.setLocalDescription = function(r) { var e; var d; var u; var l = this; var a = arguments; if (!i('setLocalDescription', r.type, this.signalingState)) return new Promise(function(e, t) { var n = new Error('Can not set remote ' + r.type + ' in state ' + l.signalingState); n.name = 'InvalidStateError', a.length > 2 && typeof a[2] === 'function' && a[2].apply(null, [n]), t(n) }); switch (r.type === 'offer' ? (e = x.splitSections(r.sdp), d = e.shift(), e.forEach(function(e, t) { e = x.parseRtpParameters(e); l.transceivers[t].localCapabilities = e }), this.transceivers.forEach(function(e, t) { l._gather(e.mid, t) })) : r.type === 'answer' && (e = x.splitSections(l.remoteDescription.sdp), d = e.shift(), u = x.matchPrefix(d, 'a=ice-lite').length > 0, e.forEach(function(e, t) { var n; var r = l.transceivers[t]; var a = r.iceGatherer; var i = r.iceTransport; var o = r.dtlsTransport; var s = r.localCapabilities; var c = r.remoteCapabilities; x.isRejected(e) || r.isDatachannel || (n = x.getIceParameters(e, d), e = x.getDtlsParameters(e, d), u && (e.role = 'server'), l.usingBundle && t !== 0 || (l._gather(r.mid, t), i.state === 'new' && i.start(a, n, u ? 'controlling' : 'controlled'), o.state === 'new' && o.start(e)), c = p(s, c), l._transceive(r, c.codecs.length > 0, !1)) })), this.localDescription = { type: r.type, sdp: r.sdp }, r.type) { case 'offer':this._updateSignalingState('have-local-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + r.type + '"') } var t = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1]; return new Promise(function(e) { t && t.apply(null), e() }) }, e.prototype.setRemoteDescription = function(S) { var w = this; var r = arguments; if (!i('setRemoteDescription', S.type, this.signalingState)) return new Promise(function(e, t) { var n = new Error('Can not set remote ' + S.type + ' in state ' + w.signalingState); n.name = 'InvalidStateError', r.length > 2 && typeof r[2] === 'function' && r[2].apply(null, [n]), t(n) }); var C = {}; this.remoteStreams.forEach(function(e) { C[e.id] = e }); var T = []; var e = x.splitSections(S.sdp); var J = e.shift(); var R = x.matchPrefix(J, 'a=ice-lite').length > 0; var P = x.matchPrefix(J, 'a=group:BUNDLE ').length > 0; this.usingBundle = P; var t = x.matchPrefix(J, 'a=ice-options:')[0]; switch (this.canTrickleIceCandidates = !!t && t.substr(14).split(' ').indexOf('trickle') >= 0, e.forEach(function(e, t) { var n; var r; var a; var i; var o; var s; var c; var d; var u; var l; var p; var f = x.splitLines(e); var m = x.getKind(e); var h = x.isRejected(e); var v = f[0].substr(2).split(' ')[2]; var g = x.getDirection(e, J); var y = x.parseMsid(e); var b = x.getMid(e) || x.generateIdentifier(); m !== 'application' || v !== 'DTLS/SCTP' ? (s = x.parseRtpParameters(e), h || (i = x.getIceParameters(e, J), (o = x.getDtlsParameters(e, J)).role = 'client'), r = x.parseRtpEncodingParameters(e), c = x.parseRtcpParameters(e), d = x.matchPrefix(e, 'a=end-of-candidates', J).length > 0, f = x.matchPrefix(e, 'a=candidate:').map(function(e) { return x.parseCandidate(e) }).filter(function(e) { return e.component === 1 }), (S.type === 'offer' || S.type === 'answer') && !h && P && t > 0 && w.transceivers[t] && (w._disposeIceAndDtlsTransports(t), w.transceivers[t].iceGatherer = w.transceivers[0].iceGatherer, w.transceivers[t].iceTransport = w.transceivers[0].iceTransport, w.transceivers[t].dtlsTransport = w.transceivers[0].dtlsTransport, w.transceivers[t].rtpSender && w.transceivers[t].rtpSender.setTransport(w.transceivers[0].dtlsTransport), w.transceivers[t].rtpReceiver && w.transceivers[t].rtpReceiver.setTransport(w.transceivers[0].dtlsTransport)), S.type !== 'offer' || h ? S.type !== 'answer' || h || (v = (p = w.transceivers[t]).iceGatherer, e = p.iceTransport, h = p.dtlsTransport, l = p.rtpReceiver, n = p.sendEncodingParameters, a = p.localCapabilities, w.transceivers[t].recvEncodingParameters = r, w.transceivers[t].remoteCapabilities = s, w.transceivers[t].rtcpParameters = c, f.length && (!R && !d || P && t !== 0 || e.state !== 'new' ? f.forEach(function(e) { D(p.iceTransport, e) }) : e.setRemoteCandidates(f)), P && t !== 0 || (e.state === 'new' && e.start(v, i, 'controlling'), h.state === 'new' && h.start(o)), w._transceive(p, g === 'sendrecv' || g === 'recvonly', g === 'sendrecv' || g === 'sendonly'), !l || g !== 'sendrecv' && g !== 'sendonly' ? delete p.rtpReceiver : (u = l.track, y ? (C[y.stream] || (C[y.stream] = new k.MediaStream()), C[y.stream].addTrack(u), T.push([u, l, C[y.stream]])) : (C.default || (C.default = new k.MediaStream()), C.default.addTrack(u), T.push([u, l, C.default])))) : ((p = w.transceivers[t] || w._createTransceiver(m)).mid = b, p.iceGatherer || (p.iceGatherer = w._createIceGatherer(t, P)), f.length && (!d || P && t !== 0 || p.iceTransport.state !== 'new' ? f.forEach(function(e) { D(p.iceTransport, e) }) : p.iceTransport.setRemoteCandidates(f)), a = k.RTCRtpReceiver.getCapabilities(m), E < 15019 && (a.codecs = a.codecs.filter(function(e) { return e.name !== 'rtx' })), n = [{ ssrc: 1001 * (2 * t + 2) }], g !== 'sendrecv' && g !== 'sendonly' || (f = !p.rtpReceiver, l = p.rtpReceiver || new k.RTCRtpReceiver(p.dtlsTransport, m), f && (u = l.track, (f = y ? (C[y.stream] || (C[y.stream] = new k.MediaStream(), Object.defineProperty(C[y.stream], 'id', { get: function() { return y.stream } })), Object.defineProperty(u, 'id', { get: function() { return y.track } }), C[y.stream]) : (C.default || (C.default = new k.MediaStream()), C.default)).addTrack(u), T.push([u, l, f]))), p.localCapabilities = a, p.remoteCapabilities = s, p.rtpReceiver = l, p.rtcpParameters = c, p.sendEncodingParameters = n, p.recvEncodingParameters = r, w._transceive(w.transceivers[t], !1, g === 'sendrecv' || g === 'sendonly'))) : w.transceivers[t] = { mid: b, isDatachannel: !0 } }), this.remoteDescription = { type: S.type, sdp: S.sdp }, S.type) { case 'offer':this._updateSignalingState('have-remote-offer'); break; case 'answer':this._updateSignalingState('stable'); break; default:throw new TypeError('unsupported type "' + S.type + '"') } return Object.keys(C).forEach(function(e) { var t; var a = C[e]; a.getTracks().length && (w.remoteStreams.indexOf(a) === -1 && (w.remoteStreams.push(a), (t = new Event('addstream')).stream = a, k.setTimeout(function() { w.dispatchEvent(t), w.onaddstream !== null && w.onaddstream(t) })), T.forEach(function(e) { var t; var n = e[0]; var r = e[1]; a.id === e[2].id && ((t = new Event('track')).track = n, t.receiver = r, t.transceiver = { receiver: r }, t.streams = [a], k.setTimeout(function() { w.dispatchEvent(t), w.ontrack !== null && w.ontrack(t) })) })) }), k.setTimeout(function() { w && w.transceivers && w.transceivers.forEach(function(e) { e.iceTransport && e.iceTransport.state === 'new' && e.iceTransport.getRemoteCandidates().length > 0 && (console.warn('Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification'), e.iceTransport.addRemoteCandidate({})) }) }, 4e3), new Promise(function(e) { r.length > 1 && typeof r[1] === 'function' && r[1].apply(null), e() }) }, e.prototype.close = function() { this.transceivers.forEach(function(e) { e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop() }), this._updateSignalingState('closed') }, e.prototype._updateSignalingState = function(e) { this.signalingState = e; e = new Event('signalingstatechange'); this.dispatchEvent(e), this.onsignalingstatechange !== null && this.onsignalingstatechange(e) }, e.prototype._maybeFireNegotiationNeeded = function() { var t = this; this.signalingState === 'stable' && !0 !== this.needNegotiation && (this.needNegotiation = !0, k.setTimeout(function() { var e; !1 !== t.needNegotiation && (t.needNegotiation = !1, e = new Event('negotiationneeded'), t.dispatchEvent(e), t.onnegotiationneeded !== null && t.onnegotiationneeded(e)) }, 0)) }, e.prototype._updateConnectionState = function() { var e; var t = { new: 0, closed: 0, connecting: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; this.transceivers.forEach(function(e) { t[e.iceTransport.state]++, t[e.dtlsTransport.state]++ }), t.connected += t.completed, e = 'new', t.failed > 0 ? e = 'failed' : t.connecting > 0 || t.checking > 0 ? e = 'connecting' : t.disconnected > 0 ? e = 'disconnected' : t.new > 0 ? e = 'new' : (t.connected > 0 || t.completed > 0) && (e = 'connected'), e !== this.iceConnectionState && (this.iceConnectionState = e, e = new Event('iceconnectionstatechange'), this.dispatchEvent(e), this.oniceconnectionstatechange !== null && this.oniceconnectionstatechange(e)) }, e.prototype.createOffer = function() { var e; var o = this; var t = arguments; arguments.length === 1 && typeof arguments[0] !== 'function' ? e = arguments[0] : arguments.length === 3 && (e = arguments[2]); var n = this.transceivers.filter(function(e) { return e.kind === 'audio' }).length; var r = this.transceivers.filter(function(e) { return e.kind === 'video' }).length; if (e) { if (e.mandatory || e.optional) throw new TypeError('Legacy mandatory/optional constraints not supported.'); void 0 !== e.offerToReceiveAudio && (n = !0 === e.offerToReceiveAudio ? 1 : !1 === e.offerToReceiveAudio ? 0 : e.offerToReceiveAudio), void 0 !== e.offerToReceiveVideo && (r = !0 === e.offerToReceiveVideo ? 1 : !1 === e.offerToReceiveVideo ? 0 : e.offerToReceiveVideo) } for (this.transceivers.forEach(function(e) { e.kind === 'audio' ? --n < 0 && (e.wantReceive = !1) : e.kind === 'video' && --r < 0 && (e.wantReceive = !1) }); n > 0 || r > 0;)n > 0 && (this._createTransceiver('audio'), n--), r > 0 && (this._createTransceiver('video'), r--); var a = x.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++); this.transceivers.forEach(function(e, t) { var n = e.track; var r = e.kind; var a = x.generateIdentifier(); e.mid = a, e.iceGatherer || (e.iceGatherer = o._createIceGatherer(t, o.usingBundle)); var i = k.RTCRtpSender.getCapabilities(r); E < 15019 && (i.codecs = i.codecs.filter(function(e) { return e.name !== 'rtx' })), i.codecs.forEach(function(e) { e.name === 'H264' && void 0 === e.parameters['level-asymmetry-allowed'] && (e.parameters['level-asymmetry-allowed'] = '1') }); a = [{ ssrc: 1001 * (2 * t + 1) }]; n && E >= 15019 && r === 'video' && (a[0].rtx = { ssrc: 1001 * (2 * t + 1) + 1 }), e.wantReceive && (e.rtpReceiver = new k.RTCRtpReceiver(e.dtlsTransport, r)), e.localCapabilities = i, e.sendEncodingParameters = a }), this._config.bundlePolicy !== 'max-compat' && (a += 'a=group:BUNDLE ' + this.transceivers.map(function(e) { return e.mid }).join(' ') + '\r\n'), a += 'a=ice-options:trickle\r\n', this.transceivers.forEach(function(e, t) { a += s(e, e.localCapabilities, 'offer', e.stream), a += 'a=rtcp-rsize\r\n', !e.iceGatherer || o.iceGatheringState === 'new' || t !== 0 && o.usingBundle || (e.iceGatherer.getLocalCandidates().forEach(function(e) { e.component = 1, a += 'a=' + x.writeCandidate(e) + '\r\n' }), e.iceGatherer.state === 'completed' && (a += 'a=end-of-candidates\r\n')) }); var i = new k.RTCSessionDescription({ type: 'offer', sdp: a }); return new Promise(function(e) { if (t.length > 0 && typeof t[0] === 'function') return t[0].apply(null, [i]), void e(); e(i) }) }, e.prototype.createAnswer = function() { var t = arguments; var r = x.writeSessionBoilerplate(this._sdpSessionId, this._sdpSessionVersion++); this.usingBundle && (r += 'a=group:BUNDLE ' + this.transceivers.map(function(e) { return e.mid }).join(' ') + '\r\n'); var a = x.splitSections(this.remoteDescription.sdp).length - 1; this.transceivers.forEach(function(e, t) { var n; a < t + 1 || (e.isDatachannel ? r += 'm=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:' + e.mid + '\r\n' : (e.stream && (e.kind === 'audio' ? n = e.stream.getAudioTracks()[0] : e.kind === 'video' && (n = e.stream.getVideoTracks()[0]), n && E >= 15019 && e.kind === 'video' && (e.sendEncodingParameters[0].rtx = { ssrc: 1001 * (2 * t + 2) + 1 })), !(t = p(e.localCapabilities, e.remoteCapabilities)).codecs.filter(function(e) { return e.name.toLowerCase() === 'rtx' }).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, r += s(e, t, 'answer', e.stream), e.rtcpParameters && e.rtcpParameters.reducedSize && (r += 'a=rtcp-rsize\r\n'))) }); var n = new k.RTCSessionDescription({ type: 'answer', sdp: r }); return new Promise(function(e) { if (t.length > 0 && typeof t[0] === 'function') return t[0].apply(null, [n]), void e(); e(n) }) }, e.prototype.addIceCandidate = function(e) { var n, t; if (e && e.candidate !== '') { if (!e.sdpMLineIndex && !e.sdpMid) throw new TypeError('sdpMLineIndex or sdpMid required'); if (this.remoteDescription) { var r = e.sdpMLineIndex; if (e.sdpMid) for (var a = 0; a < this.transceivers.length; a++) if (this.transceivers[a].mid === e.sdpMid) { r = a; break } var i = this.transceivers[r]; if (i) { if (i.isDatachannel) return Promise.resolve(); var o = Object.keys(e.candidate).length > 0 ? x.parseCandidate(e.candidate) : {}; if (o.protocol === 'tcp' && (o.port === 0 || o.port === 9)) return Promise.resolve(); if (o.component && o.component !== 1) return Promise.resolve(); (r === 0 || r > 0 && i.iceTransport !== this.transceivers[0].iceTransport) && i.iceTransport.addRemoteCandidate(o); i = e.candidate.trim(); i.indexOf('a=') === 0 && (i = i.substr(2)), (t = x.splitSections(this.remoteDescription.sdp))[r + 1] += 'a=' + (o.type ? i : 'end-of-candidates') + '\r\n', this.remoteDescription.sdp = t.join('') } else (n = new Error('Can not add ICE candidate')).name = 'OperationError' } else (n = new Error('Can not add ICE candidate without a remote description')).name = 'InvalidStateError' } else for (var s = 0; s < this.transceivers.length && (this.transceivers[s].isDatachannel || (this.transceivers[s].iceTransport.addRemoteCandidate({}), (t = x.splitSections(this.remoteDescription.sdp))[s + 1] += 'a=end-of-candidates\r\n', this.remoteDescription.sdp = t.join(''), !this.usingBundle)); s++);var c = arguments; return new Promise(function(e, t) { n ? (c.length > 2 && typeof c[2] === 'function' && c[2].apply(null, [n]), t(n)) : (c.length > 1 && typeof c[1] === 'function' && c[1].apply(null), e()) }) }, e.prototype.getStats = function() { var n = []; this.transceivers.forEach(function(t) { ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport', 'dtlsTransport'].forEach(function(e) { t[e] && n.push(t[e].getStats()) }) }); var a = arguments.length > 1 && typeof arguments[1] === 'function' && arguments[1]; return new Promise(function(t) { var r = new Map(); Promise.all(n).then(function(e) { e.forEach(function(n) { Object.keys(n).forEach(function(e) { var t; n[e].type = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[(t = n[e]).type] || t.type, r.set(e, n[e]) }) }), a && a.apply(null, r), t(r) }) }) }, e } }, { sdp: 2 }], 2: [function(e, t, n) { 'use strict'; var d = { generateIdentifier: function() { return Math.random().toString(36).substr(2, 10) } }; d.localCName = d.generateIdentifier(), d.splitLines = function(e) { return e.trim().split('\n').map(function(e) { return e.trim() }) }, d.splitSections = function(e) { return e.split('\nm=').map(function(e, t) { return (t > 0 ? 'm=' + e : e).trim() + '\r\n' }) }, d.matchPrefix = function(e, t) { return d.splitLines(e).filter(function(e) { return e.indexOf(t) === 0 }) }, d.parseCandidate = function(e) { for (var t, n = { foundation: (t = (e.indexOf('a=candidate:') === 0 ? e.substring(12) : e.substring(10)).split(' '))[0], component: parseInt(t[1], 10), protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], port: parseInt(t[5], 10), type: t[7] }, r = 8; r < t.length; r += 2) switch (t[r]) { case 'raddr':n.relatedAddress = t[r + 1]; break; case 'rport':n.relatedPort = parseInt(t[r + 1], 10); break; case 'tcptype':n.tcpType = t[r + 1]; break; case 'ufrag':n.ufrag = t[r + 1], n.usernameFragment = t[r + 1]; break; default:n[t[r]] = t[r + 1] } return n }, d.writeCandidate = function(e) { var t = []; t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.ip), t.push(e.port); var n = e.type; return t.push('typ'), t.push(n), n !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), e.ufrag && (t.push('ufrag'), t.push(e.ufrag)), 'candidate:' + t.join(' ') }, d.parseIceOptions = function(e) { return e.substr(14).split(' ') }, d.parseRtpMap = function(e) { var t = e.substr(9).split(' '); var e = { payloadType: parseInt(t.shift(), 10) }; var t = t[0].split('/'); return e.name = t[0], e.clockRate = parseInt(t[1], 10), e.numChannels = t.length === 3 ? parseInt(t[2], 10) : 1, e }, d.writeRtpMap = function(e) { var t = e.payloadType; return 'a=rtpmap:' + (t = void 0 !== e.preferredPayloadType ? e.preferredPayloadType : t) + ' ' + e.name + '/' + e.clockRate + (e.numChannels !== 1 ? '/' + e.numChannels : '') + '\r\n' }, d.parseExtmap = function(e) { e = e.substr(9).split(' '); return { id: parseInt(e[0], 10), direction: e[0].indexOf('/') > 0 ? e[0].split('/')[1] : 'sendrecv', uri: e[1] } }, d.writeExtmap = function(e) { return 'a=extmap:' + (e.id || e.preferredId) + (e.direction && e.direction !== 'sendrecv' ? '/' + e.direction : '') + ' ' + e.uri + '\r\n' }, d.parseFmtp = function(e) { for (var t, n = {}, r = e.substr(e.indexOf(' ') + 1).split(';'), a = 0; a < r.length; a++)n[(t = r[a].trim().split('='))[0].trim()] = t[1]; return n }, d.writeFmtp = function(t) { var n; var e = ''; var r = t.payloadType; return void 0 !== t.preferredPayloadType && (r = t.preferredPayloadType), t.parameters && Object.keys(t.parameters).length && (n = [], Object.keys(t.parameters).forEach(function(e) { n.push(e + '=' + t.parameters[e]) }), e += 'a=fmtp:' + r + ' ' + n.join(';') + '\r\n'), e }, d.parseRtcpFb = function(e) { e = e.substr(e.indexOf(' ') + 1).split(' '); return { type: e.shift(), parameter: e.join(' ') } }, d.writeRtcpFb = function(e) { var t = ''; var n = e.payloadType; return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function(e) { t += 'a=rtcp-fb:' + n + ' ' + e.type + (e.parameter && e.parameter.length ? ' ' + e.parameter : '') + '\r\n' }), t }, d.parseSsrcMedia = function(e) { var t = e.indexOf(' '); var n = { ssrc: parseInt(e.substr(7, t - 7), 10) }; var r = e.indexOf(':', t); return r > -1 ? (n.attribute = e.substr(t + 1, r - t - 1), n.value = e.substr(r + 1)) : n.attribute = e.substr(t + 1), n }, d.getMid = function(e) { e = d.matchPrefix(e, 'a=mid:')[0]; if (e) return e.substr(6) }, d.parseFingerprint = function(e) { e = e.substr(14).split(' '); return { algorithm: e[0].toLowerCase(), value: e[1] } }, d.getDtlsParameters = function(e, t) { return { role: 'auto', fingerprints: d.matchPrefix(e + t, 'a=fingerprint:').map(d.parseFingerprint) } }, d.writeDtlsParameters = function(e, t) { var n = 'a=setup:' + t + '\r\n'; return e.fingerprints.forEach(function(e) { n += 'a=fingerprint:' + e.algorithm + ' ' + e.value + '\r\n' }), n }, d.getIceParameters = function(e, t) { e = d.splitLines(e); return { usernameFragment: (e = e.concat(d.splitLines(t))).filter(function(e) { return e.indexOf('a=ice-ufrag:') === 0 })[0].substr(12), password: e.filter(function(e) { return e.indexOf('a=ice-pwd:') === 0 })[0].substr(10) } }, d.writeIceParameters = function(e) { return 'a=ice-ufrag:' + e.usernameFragment + '\r\na=ice-pwd:' + e.password + '\r\n' }, d.parseRtpParameters = function(e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n = d.splitLines(e)[0].split(' '), r = 3; r < n.length; r++) { var a = n[r]; var i = d.matchPrefix(e, 'a=rtpmap:' + a + ' ')[0]; if (i) { var o = d.parseRtpMap(i); var i = d.matchPrefix(e, 'a=fmtp:' + a + ' '); switch (o.parameters = i.length ? d.parseFmtp(i[0]) : {}, o.rtcpFeedback = d.matchPrefix(e, 'a=rtcp-fb:' + a + ' ').map(d.parseRtcpFb), t.codecs.push(o), o.name.toUpperCase()) { case 'RED':case 'ULPFEC':t.fecMechanisms.push(o.name.toUpperCase()) } } } return d.matchPrefix(e, 'a=extmap:').forEach(function(e) { t.headerExtensions.push(d.parseExtmap(e)) }), t }, d.writeRtpDescription = function(e, t) { var n = ''; n += 'm=' + e + ' ', n += t.codecs.length > 0 ? '9' : '0', n += ' UDP/TLS/RTP/SAVPF ', n += t.codecs.map(function(e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType }).join(' ') + '\r\n', n += 'c=IN IP4 0.0.0.0\r\n', n += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(function(e) { n += d.writeRtpMap(e), n += d.writeFmtp(e), n += d.writeRtcpFb(e) }); var r = 0; return t.codecs.forEach(function(e) { e.maxptime > r && (r = e.maxptime) }), r > 0 && (n += 'a=maxptime:' + r + '\r\n'), n += 'a=rtcp-mux\r\n', t.headerExtensions.forEach(function(e) { n += d.writeExtmap(e) }), n }, d.parseRtpEncodingParameters = function(e) { var t; var n = []; var r = d.parseRtpParameters(e); var a = r.fecMechanisms.indexOf('RED') !== -1; var i = r.fecMechanisms.indexOf('ULPFEC') !== -1; var o = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'cname' }); var s = o.length > 0 && o[0].ssrc; var o = d.matchPrefix(e, 'a=ssrc-group:FID').map(function(e) { e = e.split(' '); return e.shift(), e.map(function(e) { return parseInt(e, 10) }) }); o.length > 0 && o[0].length > 1 && o[0][0] === s && (t = o[0][1]), r.codecs.forEach(function(e) { e.name.toUpperCase() === 'RTX' && e.parameters.apt && (e = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10), rtx: { ssrc: t } }, n.push(e), a && ((e = JSON.parse(JSON.stringify(e))).fec = { ssrc: t, mechanism: i ? 'red+ulpfec' : 'red' }, n.push(e))) }), n.length === 0 && s && n.push({ ssrc: s }); var c = d.matchPrefix(e, 'b='); return c.length && (c = c[0].indexOf('b=TIAS:') === 0 ? parseInt(c[0].substr(7), 10) : c[0].indexOf('b=AS:') === 0 ? 1e3 * parseInt(c[0].substr(5), 10) * 0.95 - 16e3 : void 0, n.forEach(function(e) { e.maxBitrate = c })), n }, d.parseRtcpParameters = function(e) { var t = {}; var n = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'cname' })[0]; n && (t.cname = n.value, t.ssrc = n.ssrc); n = d.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = n.length > 0, t.compound = n.length === 0; e = d.matchPrefix(e, 'a=rtcp-mux'); return t.mux = e.length > 0, t }, d.parseMsid = function(e) { var t; var n = d.matchPrefix(e, 'a=msid:'); if (n.length === 1) return { stream: (t = n[0].substr(7).split(' '))[0], track: t[1] }; e = d.matchPrefix(e, 'a=ssrc:').map(function(e) { return d.parseSsrcMedia(e) }).filter(function(e) { return e.attribute === 'msid' }); return e.length > 0 ? { stream: (t = e[0].value.split(' '))[0], track: t[1] } : void 0 }, d.generateSessionId = function() { return Math.random().toString().substr(2, 21) }, d.writeSessionBoilerplate = function(e, t) { t = void 0 !== t ? t : 2; return 'v=0\r\no=thisisadapterortc ' + (e || d.generateSessionId()) + ' ' + t + ' IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n' }, d.writeMediaSection = function(e, t, n, r) { t = d.writeRtpDescription(e.kind, t); return t += d.writeIceParameters(e.iceGatherer.getLocalParameters()), t += d.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), n === 'offer' ? 'actpass' : 'active'), t += 'a=mid:' + e.mid + '\r\n', e.direction ? t += 'a=' + e.direction + '\r\n' : e.rtpSender && e.rtpReceiver ? t += 'a=sendrecv\r\n' : e.rtpSender ? t += 'a=sendonly\r\n' : e.rtpReceiver ? t += 'a=recvonly\r\n' : t += 'a=inactive\r\n', e.rtpSender && (t += 'a=' + (r = 'msid:' + r.id + ' ' + e.rtpSender.track.id + '\r\n'), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' ' + r, e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' ' + r, t += 'a=ssrc-group:FID ' + e.sendEncodingParameters[0].ssrc + ' ' + e.sendEncodingParameters[0].rtx.ssrc + '\r\n')), t += 'a=ssrc:' + e.sendEncodingParameters[0].ssrc + ' cname:' + d.localCName + '\r\n', e.rtpSender && e.sendEncodingParameters[0].rtx && (t += 'a=ssrc:' + e.sendEncodingParameters[0].rtx.ssrc + ' cname:' + d.localCName + '\r\n'), t }, d.getDirection = function(e, t) { for (var n = d.splitLines(e), r = 0; r < n.length; r++) switch (n[r]) { case 'a=sendrecv':case 'a=sendonly':case 'a=recvonly':case 'a=inactive':return n[r].substr(2) } return t ? d.getDirection(t) : 'sendrecv' }, d.getKind = function(e) { return d.splitLines(e)[0].split(' ')[0].substr(2) }, d.isRejected = function(e) { return e.split(' ', 2)[1] === '0' }, t.exports = d }, {}], 3: [function(n, r, e) { (function(e) { 'use strict'; var t = n('./adapter_factory.js'); r.exports = t({ window: e.window }) }).call(this, typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}) }, { './adapter_factory.js': 4 }], 4: [function(f, e, t) { 'use strict'; e.exports = function(e, t) { var n; var r = e && e.window; var a = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }; for (n in t)hasOwnProperty.call(t, n) && (a[n] = t[n]); var i = f('./utils'); var o = i.log; var e = i.detectBrowser(r); var s = { browserDetails: e, extractVersion: i.extractVersion, disableLog: i.disableLog, disableWarnings: i.disableWarnings }; var c = f('./chrome/chrome_shim') || null; var d = f('./edge/edge_shim') || null; var u = f('./firefox/firefox_shim') || null; var l = f('./safari/safari_shim') || null; var p = f('./common_shim') || null; switch (e.browser) { case 'chrome':if (!c || !c.shimPeerConnection || !a.shimChrome) return o('Chrome shim is not included in this adapter release.'), s; o('adapter.js shimming chrome.'), (s.browserShim = c).shimGetUserMedia(r), c.shimMediaStream(r), i.shimCreateObjectURL(r), c.shimSourceObject(r), c.shimPeerConnection(r), c.shimOnTrack(r), c.shimAddTrackRemoveTrack(r), c.shimGetSendersWithDtmf(r), p.shimRTCIceCandidate(r); break; case 'firefox':if (!u || !u.shimPeerConnection || !a.shimFirefox) return o('Firefox shim is not included in this adapter release.'), s; o('adapter.js shimming firefox.'), (s.browserShim = u).shimGetUserMedia(r), i.shimCreateObjectURL(r), u.shimSourceObject(r), u.shimPeerConnection(r), u.shimOnTrack(r), p.shimRTCIceCandidate(r); break; case 'edge':if (!d || !d.shimPeerConnection || !a.shimEdge) return o('MS edge shim is not included in this adapter release.'), s; o('adapter.js shimming edge.'), (s.browserShim = d).shimGetUserMedia(r), i.shimCreateObjectURL(r), d.shimPeerConnection(r), d.shimReplaceTrack(r); break; case 'safari':if (!l || !a.shimSafari) return o('Safari shim is not included in this adapter release.'), s; o('adapter.js shimming safari.'), s.browserShim = l, i.shimCreateObjectURL(r), l.shimRTCIceServerUrls(r), l.shimCallbacksAPI(r), l.shimLocalStreamsAPI(r), l.shimRemoteStreamsAPI(r), l.shimTrackEventTransceiver(r), l.shimGetUserMedia(r), p.shimRTCIceCandidate(r); break; default:o('Unsupported browser!') } return s } }, { './chrome/chrome_shim': 5, './common_shim': 7, './edge/edge_shim': 8, './firefox/firefox_shim': 10, './safari/safari_shim': 12, './utils': 13 }], 5: [function(e, t, n) { 'use strict'; var o = e('../utils.js'); var r = o.log; var a = { shimMediaStream: function(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream }, shimOnTrack: function(i) { var e; typeof i !== 'object' || !i.RTCPeerConnection || 'ontrack' in i.RTCPeerConnection.prototype || (Object.defineProperty(i.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack }, set: function(e) { this._ontrack && this.removeEventListener('track', this._ontrack), this.addEventListener('track', this._ontrack = e) } }), e = i.RTCPeerConnection.prototype.setRemoteDescription, i.RTCPeerConnection.prototype.setRemoteDescription = function() { var a = this; return a._ontrackpoly || (a._ontrackpoly = function(r) { r.stream.addEventListener('addtrack', function(t) { var e = i.RTCPeerConnection.prototype.getReceivers ? a.getReceivers().find(function(e) { return e.track && e.track.id === t.track.id }) : { track: t.track }; var n = new Event('track'); n.track = t.track, n.receiver = e, n.transceiver = { receiver: e }, n.streams = [r.stream], a.dispatchEvent(n) }), r.stream.getTracks().forEach(function(t) { var e = i.RTCPeerConnection.prototype.getReceivers ? a.getReceivers().find(function(e) { return e.track && e.track.id === t.id }) : { track: t }; var n = new Event('track'); n.track = t, n.receiver = e, n.transceiver = { receiver: e }, n.streams = [r.stream], a.dispatchEvent(n) }) }, a.addEventListener('addstream', a._ontrackpoly)), e.apply(a, arguments) }) }, shimGetSendersWithDtmf: function(e) { var r, a, t, n, i, o; typeof e === 'object' && e.RTCPeerConnection && !('getSenders' in e.RTCPeerConnection.prototype) && 'createDTMFSender' in e.RTCPeerConnection.prototype ? (r = function(e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && (t.kind === 'audio' ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }, e.RTCPeerConnection.prototype.getSenders || (e.RTCPeerConnection.prototype.getSenders = function() { return this._senders = this._senders || [], this._senders.slice() }, a = e.RTCPeerConnection.prototype.addTrack, e.RTCPeerConnection.prototype.addTrack = function(e, t) { var n = a.apply(this, arguments); return n || (n = r(this, e), this._senders.push(n)), n }, t = e.RTCPeerConnection.prototype.removeTrack, e.RTCPeerConnection.prototype.removeTrack = function(e) { t.apply(this, arguments); e = this._senders.indexOf(e); e !== -1 && this._senders.splice(e, 1) }), n = e.RTCPeerConnection.prototype.addStream, e.RTCPeerConnection.prototype.addStream = function(e) { var t = this; t._senders = t._senders || [], n.apply(t, [e]), e.getTracks().forEach(function(e) { t._senders.push(r(t, e)) }) }, i = e.RTCPeerConnection.prototype.removeStream, e.RTCPeerConnection.prototype.removeStream = function(e) { var n = this; n._senders = n._senders || [], i.apply(n, [n._streams[e.id] || e]), e.getTracks().forEach(function(t) { var e = n._senders.find(function(e) { return e.track === t }); e && n._senders.splice(n._senders.indexOf(e), 1) }) }) : typeof e === 'object' && e.RTCPeerConnection && 'getSenders' in e.RTCPeerConnection.prototype && 'createDTMFSender' in e.RTCPeerConnection.prototype && e.RTCRtpSender && !('dtmf' in e.RTCRtpSender.prototype) && (o = e.RTCPeerConnection.prototype.getSenders, e.RTCPeerConnection.prototype.getSenders = function() { var t = this; var e = o.apply(t, []); return e.forEach(function(e) { e._pc = t }), e }, Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } })) }, shimSourceObject: function(e) { var n = e && e.URL; typeof e === 'object' && (!e.HTMLMediaElement || 'srcObject' in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this._srcObject }, set: function(e) { var t = this; this._srcObject = e, this.src && n.revokeObjectURL(this.src), e ? (this.src = n.createObjectURL(e), e.addEventListener('addtrack', function() { t.src && n.revokeObjectURL(t.src), t.src = n.createObjectURL(e) }), e.addEventListener('removetrack', function() { t.src && n.revokeObjectURL(t.src), t.src = n.createObjectURL(e) })) : this.src = '' } })) }, shimAddTrackRemoveTrack: function(a) { function i(n, e) { var r = e.sdp; return Object.keys(n._reverseStreams || []).forEach(function(e) { var t = n._reverseStreams[e]; var e = n._streams[t.id]; r = r.replace(new RegExp(e.id, 'g'), t.id) }), new RTCSessionDescription({ type: e.type, sdp: r }) } var n, r, o, t, s; a.RTCPeerConnection.prototype.addTrack || (n = a.RTCPeerConnection.prototype.getLocalStreams, a.RTCPeerConnection.prototype.getLocalStreams = function() { var t = this; var e = n.apply(this); return t._reverseStreams = t._reverseStreams || {}, e.map(function(e) { return t._reverseStreams[e.id] }) }, r = a.RTCPeerConnection.prototype.addStream, a.RTCPeerConnection.prototype.addStream = function(e) { var t; var n = this; n._streams = n._streams || {}, n._reverseStreams = n._reverseStreams || {}, e.getTracks().forEach(function(t) { if (n.getSenders().find(function(e) { return e.track === t })) throw new DOMException('Track already exists.', 'InvalidAccessError') }), n._reverseStreams[e.id] || (t = new a.MediaStream(e.getTracks()), n._streams[e.id] = t, n._reverseStreams[t.id] = e, e = t), r.apply(n, [e]) }, o = a.RTCPeerConnection.prototype.removeStream, a.RTCPeerConnection.prototype.removeStream = function(e) { var t = this; t._streams = t._streams || {}, t._reverseStreams = t._reverseStreams || {}, o.apply(t, [t._streams[e.id] || e]), delete t._reverseStreams[(t._streams[e.id] || e).id], delete t._streams[e.id] }, a.RTCPeerConnection.prototype.addTrack = function(t, e) { var n = this; if (n.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); var r = [].slice.call(arguments, 1); if (r.length !== 1 || !r[0].getTracks().find(function(e) { return e === t })) throw new DOMException('The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.', 'NotSupportedError'); if (n.getSenders().find(function(e) { return e.track === t })) throw new DOMException('Track already exists.', 'InvalidAccessError'); n._streams = n._streams || {}, n._reverseStreams = n._reverseStreams || {}; r = n._streams[e.id]; return r ? (r.addTrack(t), Promise.resolve().then(function() { n.dispatchEvent(new Event('negotiationneeded')) })) : (r = new a.MediaStream([t]), n._streams[e.id] = r, n._reverseStreams[r.id] = e, n.addStream(r)), n.getSenders().find(function(e) { return e.track === t }) }, ['createOffer', 'createAnswer'].forEach(function(e) { var r = a.RTCPeerConnection.prototype[e]; a.RTCPeerConnection.prototype[e] = function() { var t = this; var n = arguments; return arguments.length && typeof arguments[0] === 'function' ? r.apply(t, [function(e) { e = i(t, e); n[0].apply(null, [e]) }, function(e) { n[1] && n[1].apply(null, e) }, arguments[2]]) : r.apply(t, arguments).then(function(e) { return i(t, e) }) } }), t = a.RTCPeerConnection.prototype.setLocalDescription, a.RTCPeerConnection.prototype.setLocalDescription = function() { var n, e, r; return arguments.length && arguments[0].type && (arguments[0] = (n = this, r = (e = arguments[0]).sdp, Object.keys(n._reverseStreams || []).forEach(function(e) { var t = n._reverseStreams[e]; var e = n._streams[t.id]; r = r.replace(new RegExp(t.id, 'g'), e.id) }), new RTCSessionDescription({ type: e.type, sdp: r }))), t.apply(this, arguments) }, s = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, 'localDescription'), Object.defineProperty(a.RTCPeerConnection.prototype, 'localDescription', { get: function() { var e = s.get.apply(this); return e.type === '' ? e : i(this, e) } }), a.RTCPeerConnection.prototype.removeTrack = function(t) { var n; var r = this; if (r.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); if (!t._pc) throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.', 'TypeError'); if (t._pc !== r) throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError'); r._streams = r._streams || {}, Object.keys(r._streams).forEach(function(e) { r._streams[e].getTracks().find(function(e) { return t.track === e }) && (n = r._streams[e]) }), n && (n.getTracks().length === 1 ? r.removeStream(n) : n.removeTrack(t.track), r.dispatchEvent(new Event('negotiationneeded'))) }) }, shimPeerConnection: function(n) { var i; var e = o.detectBrowser(n); n.RTCPeerConnection ? (i = n.RTCPeerConnection, n.RTCPeerConnection = function(e, t) { if (e && e.iceServers) { for (var n = [], r = 0; r < e.iceServers.length; r++) { var a = e.iceServers[r]; !a.hasOwnProperty('urls') && a.hasOwnProperty('url') ? (o.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (a = JSON.parse(JSON.stringify(a))).urls = a.url, n.push(a)) : n.push(e.iceServers[r]) }e.iceServers = n } return new i(e, t) }, n.RTCPeerConnection.prototype = i.prototype, Object.defineProperty(n.RTCPeerConnection, 'generateCertificate', { get: function() { return i.generateCertificate } })) : (n.RTCPeerConnection = function(e, t) { return r('PeerConnection'), e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy), new n.webkitRTCPeerConnection(e, t) }, n.RTCPeerConnection.prototype = n.webkitRTCPeerConnection.prototype, n.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(n.RTCPeerConnection, 'generateCertificate', { get: function() { return n.webkitRTCPeerConnection.generateCertificate } })); var s = n.RTCPeerConnection.prototype.getStats; n.RTCPeerConnection.prototype.getStats = function(e, t, n) { var r = this; var a = arguments; if (arguments.length > 0 && typeof e === 'function') return s.apply(this, arguments); if (s.length === 0 && (arguments.length === 0 || typeof e !== 'function')) return s.apply(this, []); function i(e) { var r = {}; return e.result().forEach(function(t) { var n = { id: t.id, timestamp: t.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[t.type] || t.type }; t.names().forEach(function(e) { n[e] = t.stat(e) }), r[n.id] = n }), r } function o(t) { return new Map(Object.keys(t).map(function(e) { return [e, t[e]] })) } return arguments.length >= 2 ? s.apply(this, [function(e) { a[1](o(i(e))) }, e]) : new Promise(function(t, e) { s.apply(r, [function(e) { t(o(i(e))) }, e]) }).then(t, n) }, e.version < 51 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var a = n.RTCPeerConnection.prototype[e]; n.RTCPeerConnection.prototype[e] = function() { var n = arguments; var r = this; var e = new Promise(function(e, t) { a.apply(r, [n[0], e, t]) }); return n.length < 2 ? e : e.then(function() { n[1].apply(null, []) }, function(e) { n.length >= 3 && n[2].apply(null, [e]) }) } }), e.version < 52 && ['createOffer', 'createAnswer'].forEach(function(e) { var a = n.RTCPeerConnection.prototype[e]; n.RTCPeerConnection.prototype[e] = function() { var n = this; if (arguments.length < 1 || arguments.length === 1 && typeof arguments[0] === 'object') { var r = arguments.length === 1 ? arguments[0] : void 0; return new Promise(function(e, t) { a.apply(n, [e, t, r]) }) } return a.apply(this, arguments) } }), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var t = n.RTCPeerConnection.prototype[e]; n.RTCPeerConnection.prototype[e] = function() { return arguments[0] = new (e === 'addIceCandidate' ? n.RTCIceCandidate : n.RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }); var t = n.RTCPeerConnection.prototype.addIceCandidate; n.RTCPeerConnection.prototype.addIceCandidate = function() { return arguments[0] ? t.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) } } }; t.exports = { shimMediaStream: a.shimMediaStream, shimOnTrack: a.shimOnTrack, shimAddTrackRemoveTrack: a.shimAddTrackRemoveTrack, shimGetSendersWithDtmf: a.shimGetSendersWithDtmf, shimSourceObject: a.shimSourceObject, shimPeerConnection: a.shimPeerConnection, shimGetUserMedia: e('./getusermedia') } }, { '../utils.js': 13, './getusermedia': 6 }], 6: [function(e, t, n) { 'use strict'; var c = e('../utils.js'); var d = c.log; t.exports = function(e) { function o(a) { if (typeof a !== 'object' || a.mandatory || a.optional) return a; var i = {}; return Object.keys(a).forEach(function(t) { var n, r, e; t !== 'require' && t !== 'advanced' && t !== 'mediaSource' && (void 0 !== (n = typeof a[t] === 'object' ? a[t] : { ideal: a[t] }).exact && typeof n.exact === 'number' && (n.min = n.max = n.exact), r = function(e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t }, void 0 !== n.ideal && (i.optional = i.optional || [], e = {}, typeof n.ideal === 'number' ? (e[r('min', t)] = n.ideal, i.optional.push(e), (e = {})[r('max', t)] = n.ideal) : e[r('', t)] = n.ideal, i.optional.push(e)), void 0 !== n.exact && typeof n.exact !== 'number' ? (i.mandatory = i.mandatory || {}, i.mandatory[r('', t)] = n.exact) : ['min', 'max'].forEach(function(e) { void 0 !== n[e] && (i.mandatory = i.mandatory || {}, i.mandatory[r(e, t)] = n[e]) })) }), a.advanced && (i.optional = (i.optional || []).concat(a.advanced)), i } function r(n, r) { if ((n = JSON.parse(JSON.stringify(n))) && typeof n.audio === 'object' && ((e = function(e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) })((n = JSON.parse(JSON.stringify(n))).audio, 'autoGainControl', 'googAutoGainControl'), e(n.audio, 'noiseSuppression', 'googNoiseSuppression'), n.audio = o(n.audio)), n && typeof n.video === 'object') { var a; var i = (i = n.video.facingMode) && (typeof i === 'object' ? i : { ideal: i }); var e = t.version < 61; if (i && (i.exact === 'user' || i.exact === 'environment' || i.ideal === 'user' || i.ideal === 'environment') && (!s.mediaDevices.getSupportedConstraints || !s.mediaDevices.getSupportedConstraints().facingMode || e)) if (delete n.video.facingMode, i.exact === 'environment' || i.ideal === 'environment' ? a = ['back', 'rear'] : i.exact !== 'user' && i.ideal !== 'user' || (a = ['front']), a) return s.mediaDevices.enumerateDevices().then(function(e) { var t = (e = e.filter(function(e) { return e.kind === 'videoinput' })).find(function(t) { return a.some(function(e) { return t.label.toLowerCase().indexOf(e) !== -1 }) }); return (t = !t && e.length && a.indexOf('back') !== -1 ? e[e.length - 1] : t) && (n.video.deviceId = i.exact ? { exact: t.deviceId } : { ideal: t.deviceId }), n.video = o(n.video), d('chrome: ' + JSON.stringify(n)), r(n) }); n.video = o(n.video) } return d('chrome: ' + JSON.stringify(n)), r(n) } function a(e) { return { name: { PermissionDeniedError: 'NotAllowedError', InvalidStateError: 'NotReadableError', DevicesNotFoundError: 'NotFoundError', ConstraintNotSatisfiedError: 'OverconstrainedError', TrackStartError: 'NotReadableError', MediaDeviceFailedDueToShutdown: 'NotReadableError', MediaDeviceKillSwitchOn: 'NotReadableError' }[e.name] || e.name, message: e.message, constraint: e.constraintName, toString: function() { return this.name + (this.message && ': ') + this.message } } } var t = c.detectBrowser(e); var s = e && e.navigator; s.getUserMedia = function(e, t, n) { r(e, function(e) { s.webkitGetUserMedia(e, t, function(e) { n && n(a(e)) }) }) }; function n(n) { return new Promise(function(e, t) { s.getUserMedia(n, e, t) }) } var i; s.mediaDevices || (s.mediaDevices = { getUserMedia: n, enumerateDevices: function() { return new Promise(function(t) { var n = { audio: 'audioinput', video: 'videoinput' }; return e.MediaStreamTrack.getSources(function(e) { t(e.map(function(e) { return { label: e.label, kind: n[e.kind], deviceId: e.id, groupId: '' } })) }) }) }, getSupportedConstraints: function() { return { deviceId: !0, echoCancellation: !0, facingMode: !0, frameRate: !0, height: !0, width: !0 } } }), s.mediaDevices.getUserMedia ? (i = s.mediaDevices.getUserMedia.bind(s.mediaDevices), s.mediaDevices.getUserMedia = function(e) { return r(e, function(t) { return i(t).then(function(e) { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) { e.stop() }), new DOMException('', 'NotFoundError'); return e }, function(e) { return Promise.reject(a(e)) }) }) }) : s.mediaDevices.getUserMedia = n, void 0 === s.mediaDevices.addEventListener && (s.mediaDevices.addEventListener = function() { d('Dummy mediaDevices.addEventListener called.') }), void 0 === s.mediaDevices.removeEventListener && (s.mediaDevices.removeEventListener = function() { d('Dummy mediaDevices.removeEventListener called.') }) } }, { '../utils.js': 13 }], 7: [function(e, t, n) { 'use strict'; function a(e, r, a) { var i, o; e.RTCPeerConnection && (e = e.RTCPeerConnection.prototype, i = e.addEventListener, e.addEventListener = function(e, t) { if (e !== r) return i.apply(this, arguments); function n(e) { t(a(e)) } return this._eventMap = this._eventMap || {}, this._eventMap[t] = n, i.apply(this, [e, n]) }, o = e.removeEventListener, e.removeEventListener = function(e, t) { if (e !== r || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments); var n = this._eventMap[t]; return delete this._eventMap[t], o.apply(this, [e, n]) }, Object.defineProperty(e, 'on' + r, { get: function() { return this['_on' + r] }, set: function(e) { this['_on' + r] && (this.removeEventListener(r, this['_on' + r]), delete this['_on' + r]), e && this.addEventListener(r, this['_on' + r] = e) } })) } var i = e('sdp'); t.exports = { shimRTCIceCandidate: function(t) { var r; t.RTCIceCandidate && 'foundation' in t.RTCIceCandidate.prototype || (r = t.RTCIceCandidate, t.RTCIceCandidate = function(e) { typeof e === 'object' && e.candidate && e.candidate.indexOf('a=') === 0 && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)); var t = new r(e); var e = i.parseCandidate(e.candidate); var n = Object.assign(t, e); return n.toJSON = function() { return { candidate: n.candidate, sdpMid: n.sdpMid, sdpMLineIndex: n.sdpMLineIndex, usernameFragment: n.usernameFragment } }, n }, a(t, 'icecandidate', function(e) { return e.candidate && Object.defineProperty(e, 'candidate', { value: new t.RTCIceCandidate(e.candidate), writable: 'false' }), e })) } } }, { sdp: 2 }], 8: [function(e, t, n) { 'use strict'; var r = e('../utils'); var a = e('rtcpeerconnection-shim'); t.exports = { shimGetUserMedia: e('./getusermedia'), shimPeerConnection: function(e) { var n; var t = r.detectBrowser(e); e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function(e) { return e }), e.RTCSessionDescription || (e.RTCSessionDescription = function(e) { return e }), t.version < 15025) && (n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, 'enabled'), Object.defineProperty(e.MediaStreamTrack.prototype, 'enabled', { set: function(e) { n.set.call(this, e); var t = new Event('enabled'); t.enabled = e, this.dispatchEvent(t) } })), !e.RTCRtpSender || 'dtmf' in e.RTCRtpSender.prototype || Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function() { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === 'video' && (this._dtmf = null)), this._dtmf } }), e.RTCPeerConnection = a(e, t.version) }, shimReplaceTrack: function(e) { !e.RTCRtpSender || 'replaceTrack' in e.RTCRtpSender.prototype || (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } } }, { '../utils': 13, './getusermedia': 9, 'rtcpeerconnection-shim': 1 }], 9: [function(e, t, n) { 'use strict'; t.exports = function(e) { var e = e && e.navigator; var t = e.mediaDevices.getUserMedia.bind(e.mediaDevices); e.mediaDevices.getUserMedia = function(e) { return t(e).catch(function(e) { return Promise.reject({ name: { PermissionDeniedError: 'NotAllowedError' }[(e = e).name] || e.name, message: e.message, constraint: e.constraint, toString: function() { return this.name } }) }) } } }, {}], 10: [function(e, t, n) { 'use strict'; var r = e('../utils'); var a = { shimOnTrack: function(e) { typeof e !== 'object' || !e.RTCPeerConnection || 'ontrack' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'ontrack', { get: function() { return this._ontrack }, set: function(e) { this._ontrack && (this.removeEventListener('track', this._ontrack), this.removeEventListener('addstream', this._ontrackpoly)), this.addEventListener('track', this._ontrack = e), this.addEventListener('addstream', this._ontrackpoly = function(n) { n.stream.getTracks().forEach(function(e) { var t = new Event('track'); t.track = e, t.receiver = { track: e }, t.transceiver = { receiver: t.receiver }, t.streams = [n.stream], this.dispatchEvent(t) }.bind(this)) }.bind(this)) } }), typeof e === 'object' && e.RTCPeerConnection && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function() { return { receiver: this.receiver } } }) }, shimSourceObject: function(e) { typeof e === 'object' && (!e.HTMLMediaElement || 'srcObject' in e.HTMLMediaElement.prototype || Object.defineProperty(e.HTMLMediaElement.prototype, 'srcObject', { get: function() { return this.mozSrcObject }, set: function(e) { this.mozSrcObject = e } })) }, shimPeerConnection: function(s) { var e; var i; var n; var c = r.detectBrowser(s); typeof s === 'object' && (s.RTCPeerConnection || s.mozRTCPeerConnection) && (s.RTCPeerConnection || (s.RTCPeerConnection = function(e, t) { if (c.version < 38 && e && e.iceServers) { for (var n = [], r = 0; r < e.iceServers.length; r++) { var a = e.iceServers[r]; if (a.hasOwnProperty('urls')) for (var i = 0; i < a.urls.length; i++) { var o = { url: a.urls[i] }; a.urls[i].indexOf('turn') === 0 && (o.username = a.username, o.credential = a.credential), n.push(o) } else n.push(e.iceServers[r]) }e.iceServers = n } return new s.mozRTCPeerConnection(e, t) }, s.RTCPeerConnection.prototype = s.mozRTCPeerConnection.prototype, s.mozRTCPeerConnection.generateCertificate && Object.defineProperty(s.RTCPeerConnection, 'generateCertificate', { get: function() { return s.mozRTCPeerConnection.generateCertificate } }), s.RTCSessionDescription = s.mozRTCSessionDescription, s.RTCIceCandidate = s.mozRTCIceCandidate), ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function(e) { var t = s.RTCPeerConnection.prototype[e]; s.RTCPeerConnection.prototype[e] = function() { return arguments[0] = new (e === 'addIceCandidate' ? s.RTCIceCandidate : s.RTCSessionDescription)(arguments[0]), t.apply(this, arguments) } }), e = s.RTCPeerConnection.prototype.addIceCandidate, s.RTCPeerConnection.prototype.addIceCandidate = function() { return arguments[0] ? e.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }, i = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }, n = s.RTCPeerConnection.prototype.getStats, s.RTCPeerConnection.prototype.getStats = function(e, a, t) { return n.apply(this, [e || null]).then(function(n) { if (c.version < 48 && (t = n, r = new Map(), Object.keys(t).forEach(function(e) { r.set(e, t[e]), r[e] = t[e] }), n = r), c.version < 53 && !a) try { n.forEach(function(e) { e.type = i[e.type] || e.type }) } catch (e) { if (e.name !== 'TypeError') throw e; n.forEach(function(e, t) { n.set(t, Object.assign({}, e, { type: i[e.type] || e.type })) }) } var t, r; return n }).then(a, t) }) } }; t.exports = { shimOnTrack: a.shimOnTrack, shimSourceObject: a.shimSourceObject, shimPeerConnection: a.shimPeerConnection, shimGetUserMedia: e('./getusermedia') } }, { '../utils': 13, './getusermedia': 11 }], 11: [function(e, t, n) { 'use strict'; var l = e('../utils'); var p = l.log; t.exports = function(e) { function a(e) { return { name: { InternalError: 'NotReadableError', NotSupportedError: 'TypeError', PermissionDeniedError: 'NotAllowedError', SecurityError: 'NotAllowedError' }[e.name] || e.name, message: { 'The operation is insecure.': 'The request is not allowed by the user agent or the platform in the current context.' }[e.message] || e.message, constraint: e.constraint, toString: function() { return this.name + (this.message && ': ') + this.message } } } function r(e, t, n) { function r(r) { if (typeof r !== 'object' || r.require) return r; var a = []; return Object.keys(r).forEach(function(e) { var t, n; e !== 'require' && e !== 'advanced' && e !== 'mediaSource' && (void 0 === (t = r[e] = typeof r[e] === 'object' ? r[e] : { ideal: r[e] }).min && void 0 === t.max && void 0 === t.exact || a.push(e), void 0 !== t.exact && (typeof t.exact === 'number' ? t.min = t.max = t.exact : r[e] = t.exact, delete t.exact), void 0 !== t.ideal && (r.advanced = r.advanced || [], n = {}, typeof t.ideal === 'number' ? n[e] = { min: t.ideal, max: t.ideal } : n[e] = t.ideal, r.advanced.push(n), delete t.ideal, Object.keys(t).length || delete r[e])) }), a.length && (r.require = a), r } return e = JSON.parse(JSON.stringify(e)), d.version < 38 && (p('spec: ' + JSON.stringify(e)), e.audio && (e.audio = r(e.audio)), e.video && (e.video = r(e.video)), p('ff37: ' + JSON.stringify(e))), u.mozGetUserMedia(e, t, function(e) { n(a(e)) }) } var t; var n; var i; var o; var s; var c; var d = l.detectBrowser(e); var u = e && e.navigator; var e = e && e.MediaStreamTrack; u.mediaDevices || (u.mediaDevices = { getUserMedia: function(n) { return new Promise(function(e, t) { r(n, e, t) }) }, addEventListener: function() {}, removeEventListener: function() {} }), u.mediaDevices.enumerateDevices = u.mediaDevices.enumerateDevices || function() { return new Promise(function(e) { e([{ kind: 'audioinput', deviceId: 'default', label: '', groupId: '' }, { kind: 'videoinput', deviceId: 'default', label: '', groupId: '' }]) }) }, d.version < 41 && (t = u.mediaDevices.enumerateDevices.bind(u.mediaDevices), u.mediaDevices.enumerateDevices = function() { return t().then(void 0, function(e) { if (e.name === 'NotFoundError') return []; throw e }) }), d.version < 49 && (n = u.mediaDevices.getUserMedia.bind(u.mediaDevices), u.mediaDevices.getUserMedia = function(t) { return n(t).then(function(e) { if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(function(e) { e.stop() }), new DOMException('The object can not be found here.', 'NotFoundError'); return e }, function(e) { return Promise.reject(a(e)) }) }), d.version > 55 && 'autoGainControl' in u.mediaDevices.getSupportedConstraints() || (i = function(e, t, n) { t in e && !(n in e) && (e[n] = e[t], delete e[t]) }, o = u.mediaDevices.getUserMedia.bind(u.mediaDevices), u.mediaDevices.getUserMedia = function(e) { return typeof e === 'object' && typeof e.audio === 'object' && (e = JSON.parse(JSON.stringify(e)), i(e.audio, 'autoGainControl', 'mozAutoGainControl'), i(e.audio, 'noiseSuppression', 'mozNoiseSuppression')), o(e) }, e && e.prototype.getSettings && (s = e.prototype.getSettings, e.prototype.getSettings = function() { var e = s.apply(this, arguments); return i(e, 'mozAutoGainControl', 'autoGainControl'), i(e, 'mozNoiseSuppression', 'noiseSuppression'), e }), e && e.prototype.applyConstraints && (c = e.prototype.applyConstraints, e.prototype.applyConstraints = function(e) { return this.kind === 'audio' && typeof e === 'object' && (e = JSON.parse(JSON.stringify(e)), i(e, 'autoGainControl', 'mozAutoGainControl'), i(e, 'noiseSuppression', 'mozNoiseSuppression')), c.apply(this, [e]) })), u.getUserMedia = function(e, t, n) { if (d.version < 44) return r(e, t, n); l.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia'), u.mediaDevices.getUserMedia(e).then(t, n) } } }, { '../utils': 13 }], 12: [function(e, t, n) { 'use strict'; var o = e('../utils'); var e = { shimLocalStreamsAPI: function(e) { var r; typeof e === 'object' && e.RTCPeerConnection && ('getLocalStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() { return this._localStreams || (this._localStreams = []), this._localStreams }), 'getStreamById' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getStreamById = function(t) { var n = null; return this._localStreams && this._localStreams.forEach(function(e) { e.id === t && (n = e) }), this._remoteStreams && this._remoteStreams.forEach(function(e) { e.id === t && (n = e) }), n }), 'addStream' in e.RTCPeerConnection.prototype || (r = e.RTCPeerConnection.prototype.addTrack, e.RTCPeerConnection.prototype.addStream = function(t) { this._localStreams || (this._localStreams = []), this._localStreams.indexOf(t) === -1 && this._localStreams.push(t); var n = this; t.getTracks().forEach(function(e) { r.call(n, e, t) }) }, e.RTCPeerConnection.prototype.addTrack = function(e, t) { t && (this._localStreams ? this._localStreams.indexOf(t) === -1 && this._localStreams.push(t) : this._localStreams = [t]), r.call(this, e, t) }), 'removeStream' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) { this._localStreams || (this._localStreams = []); var t; var n; var r = this._localStreams.indexOf(e); r !== -1 && (this._localStreams.splice(r, 1), t = this, n = e.getTracks(), this.getSenders().forEach(function(e) { n.indexOf(e.track) !== -1 && t.removeTrack(e) })) })) }, shimRemoteStreamsAPI: function(e) { typeof e === 'object' && e.RTCPeerConnection && ('getRemoteStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() { return this._remoteStreams || [] }), 'onaddstream' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'onaddstream', { get: function() { return this._onaddstream }, set: function(e) { this._onaddstream && (this.removeEventListener('addstream', this._onaddstream), this.removeEventListener('track', this._onaddstreampoly)), this.addEventListener('addstream', this._onaddstream = e), this.addEventListener('track', this._onaddstreampoly = function(e) { var t = e.streams[0]; this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.indexOf(t) >= 0 || (this._remoteStreams.push(t), (t = new Event('addstream')).stream = e.streams[0], this.dispatchEvent(t)) }.bind(this)) } })) }, shimCallbacksAPI: function(e) { var t, r, a, i, o, s; typeof e === 'object' && e.RTCPeerConnection && (t = e.RTCPeerConnection.prototype, r = t.createOffer, a = t.createAnswer, i = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate, t.createOffer = function(e, t) { var n = arguments.length >= 2 ? arguments[2] : e; var n = r.apply(this, [n]); return t ? (n.then(e, t), Promise.resolve()) : n }, t.createAnswer = function(e, t) { var n = arguments.length >= 2 ? arguments[2] : e; var n = a.apply(this, [n]); return t ? (n.then(e, t), Promise.resolve()) : n }, e = function(e, t, n) { e = i.apply(this, [e]); return n ? (e.then(t, n), Promise.resolve()) : e }, t.setLocalDescription = e, e = function(e, t, n) { e = o.apply(this, [e]); return n ? (e.then(t, n), Promise.resolve()) : e }, t.setRemoteDescription = e, e = function(e, t, n) { e = s.apply(this, [e]); return n ? (e.then(t, n), Promise.resolve()) : e }, t.addIceCandidate = e) }, shimGetUserMedia: function(e) { var r = e && e.navigator; r.getUserMedia || (r.webkitGetUserMedia ? r.getUserMedia = r.webkitGetUserMedia.bind(r) : r.mediaDevices && r.mediaDevices.getUserMedia && (r.getUserMedia = function(e, t, n) { r.mediaDevices.getUserMedia(e).then(t, n) })) }, shimRTCIceServerUrls: function(e) { var i = e.RTCPeerConnection; e.RTCPeerConnection = function(e, t) { if (e && e.iceServers) { for (var n = [], r = 0; r < e.iceServers.length; r++) { var a = e.iceServers[r]; !a.hasOwnProperty('urls') && a.hasOwnProperty('url') ? (o.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (a = JSON.parse(JSON.stringify(a))).urls = a.url, delete a.url, n.push(a)) : n.push(e.iceServers[r]) }e.iceServers = n } return new i(e, t) }, e.RTCPeerConnection.prototype = i.prototype, Object.defineProperty(e.RTCPeerConnection, 'generateCertificate', { get: function() { return i.generateCertificate } }) }, shimTrackEventTransceiver: function(e) { typeof e === 'object' && e.RTCPeerConnection && 'receiver' in e.RTCTrackEvent.prototype && !e.RTCTransceiver && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function() { return { receiver: this.receiver } } }) } }; t.exports = { shimCallbacksAPI: e.shimCallbacksAPI, shimLocalStreamsAPI: e.shimLocalStreamsAPI, shimRemoteStreamsAPI: e.shimRemoteStreamsAPI, shimGetUserMedia: e.shimGetUserMedia, shimRTCIceServerUrls: e.shimRTCIceServerUrls, shimTrackEventTransceiver: e.shimTrackEventTransceiver } }, { '../utils': 13 }], 13: [function(e, t, n) { 'use strict'; var r = !0; var a = !0; var c = { disableLog: function(e) { return typeof e !== 'boolean' ? new Error('Argument type: ' + typeof e + '. Please use a boolean.') : (r = e) ? 'adapter.js logging disabled' : 'adapter.js logging enabled' }, disableWarnings: function(e) { return typeof e !== 'boolean' ? new Error('Argument type: ' + typeof e + '. Please use a boolean.') : (a = !e, 'adapter.js deprecation warnings ' + (e ? 'disabled' : 'enabled')) }, log: function() { typeof window === 'object' && (r || typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments)) }, deprecated: function(e, t) { a && console.warn(e + ' is deprecated, please use ' + t + ' instead.') }, extractVersion: function(e, t, n) { t = e.match(t); return t && t.length >= n && parseInt(t[n], 10) }, detectBrowser: function(e) { var t = e && e.navigator; var n = { browser: null, version: null }; if (void 0 === e || !e.navigator) return n.browser = 'Not a browser.', n; if (t.mozGetUserMedia)n.browser = 'firefox', n.version = this.extractVersion(t.userAgent, /Firefox\/(\d+)\./, 1); else if (t.webkitGetUserMedia) if (e.webkitRTCPeerConnection)n.browser = 'chrome', n.version = this.extractVersion(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!t.userAgent.match(/Version\/(\d+).(\d+)/)) return n.browser = 'Unsupported webkit-based browser with GUM support but no WebRTC support.', n; n.browser = 'safari', n.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1) } else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/))n.browser = 'edge', n.version = this.extractVersion(t.userAgent, /Edge\/(\d+).(\d+)$/, 2); else { if (!t.mediaDevices || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return n.browser = 'Not a supported browser.', n; n.browser = 'safari', n.version = this.extractVersion(t.userAgent, /AppleWebKit\/(\d+)\./, 1) } return n }, shimCreateObjectURL: function(e) { var n; var t; var r; var a; var i; var o; var s = e && e.URL; typeof e === 'object' && e.HTMLMediaElement && 'srcObject' in e.HTMLMediaElement.prototype && s.createObjectURL && s.revokeObjectURL && (n = s.createObjectURL.bind(s), t = s.revokeObjectURL.bind(s), r = new Map(), a = 0, s.createObjectURL = function(e) { if ('getTracks' in e) { var t = 'polyblob:' + ++a; return r.set(t, e), c.deprecated('URL.createObjectURL(stream)', 'elem.srcObject = stream'), t } return n(e) }, s.revokeObjectURL = function(e) { t(e), r.delete(e) }, i = Object.getOwnPropertyDescriptor(e.HTMLMediaElement.prototype, 'src'), Object.defineProperty(e.HTMLMediaElement.prototype, 'src', { get: function() { return i.get.apply(this) }, set: function(e) { return this.srcObject = r.get(e) || null, i.set.apply(this, [e]) } }), o = e.HTMLMediaElement.prototype.setAttribute, e.HTMLMediaElement.prototype.setAttribute = function() { return arguments.length === 2 && ('' + arguments[0]).toLowerCase() === 'src' && (this.srcObject = r.get(arguments[1]) || null), o.apply(this, arguments) }) } }; t.exports = { log: c.log, deprecated: c.deprecated, disableLog: c.disableLog, disableWarnings: c.disableWarnings, extractVersion: c.extractVersion, shimCreateObjectURL: c.shimCreateObjectURL, detectBrowser: c.detectBrowser.bind(c) } }, {}] }, {}, [3]))(3) })), Janus.sessions = {}, Janus.extensionId = 'hapfgfdkleiggjjpfpenajgdnfckjpaj', Janus.isExtensionEnabled = function() { if (window.navigator.userAgent.match('Chrome')) { var e = parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10); var t = 33; return window.navigator.userAgent.match('Linux') && (t = 35), e >= 26 && e <= t || Janus.checkJanusExtension() } return !0 }, Janus.useDefaultDependencies = function(e) { var n = e && e.fetch || fetch; var a = e && e.Promise || Promise; var r = e && e.WebSocket || WebSocket; return console.log(adapter), { newWebSocket: function(e, t) { return new r(e, t) }, isArray: function(e) { return Array.isArray(e) }, checkJanusExtension: function() { return document.querySelector('#janus-extension-installed') !== null }, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function(e, r) { var t = { method: r.verb, cache: 'no-cache' }; void 0 !== r.withCredentials && (t.credentials = !0 === r.withCredentials ? 'include' : r.withCredentials || 'omit'), void 0 !== r.body && (t.body = JSON.stringify(r.body)); e = n(e, t).catch(function(e) { return a.reject({ message: 'Probably a network error, is the gateway down?', error: e }) }); return void 0 !== r.timeout && (t = new a(function(e, t) { var n = setTimeout(function() { return clearTimeout(n), t({ message: 'Request timed out', timeout: r.timeout }) }, r.timeout) }), e = a.race([e, t])), e.then(function(t) { return t.ok ? typeof r.success === typeof Janus.noop ? t.json().then(function(e) { r.success(e) }).catch(function(e) { return a.reject({ message: 'Failed to parse response body', error: e, response: t }) }) : void 0 : a.reject({ message: 'API call failed', response: t }) }).catch(function(e) { typeof r.error === typeof Janus.noop && r.error(e.message || '<< internal error >>', e) }), e } } }, Janus.useOldDependencies = function(e) { var a = e && e.jQuery || jQuery; var n = e && e.WebSocket || WebSocket; return { newWebSocket: function(e, t) { return new n(e, t) }, isArray: function(e) { return a.isArray(e) }, checkJanusExtension: function() { return a('#janus-extension-installed').length > 0 }, webRTCAdapter: e && e.adapter || adapter, httpAPICall: function(e, r) { var t = void 0 !== r.body ? { contentType: 'application/json', data: JSON.stringify(r.body) } : {}; var n = void 0 !== r.withCredentials ? { xhrFields: { withCredentials: r.withCredentials } } : {}; return a.ajax(a.extend(t, n, { url: e, type: r.verb, cache: !1, dataType: 'json', async: r.async, timeout: r.timeout, success: function(e) { typeof r.success === typeof Janus.noop && r.success(e) }, error: function(e, t, n) { typeof r.error === typeof Janus.noop && r.error(t, n) } })) } } }, Janus.noop = function() {}, Janus.init = function(e) { if ((e = e || {}).callback = typeof e.callback === 'function' ? e.callback : Janus.noop, !0 === Janus.initDone)e.callback(); else { if (typeof console !== 'undefined' && void 0 !== console.log || (console = { log: function() {} }), Janus.trace = Janus.noop, Janus.debug = Janus.noop, Janus.vdebug = Janus.noop, Janus.log = Janus.noop, Janus.warn = Janus.noop, Janus.error = Janus.noop, !0 === e.debug || e.debug === 'all')Janus.trace = console.trace.bind(console), Janus.debug = console.debug.bind(console), Janus.vdebug = console.debug.bind(console), Janus.log = console.log.bind(console), Janus.warn = console.warn.bind(console), Janus.error = console.error.bind(console); else if (Array.isArray(e.debug)) for (var t in e.debug) { var n = e.debug[t]; switch (n) { case 'trace':Janus.trace = console.trace.bind(console); break; case 'debug':Janus.debug = console.debug.bind(console); break; case 'vdebug':Janus.vdebug = console.debug.bind(console); break; case 'log':Janus.log = console.log.bind(console); break; case 'warn':Janus.warn = console.warn.bind(console); break; case 'error':Janus.error = console.error.bind(console); break; default:console.error("Unknown debugging option '" + n + "' (supported: 'trace', 'debug', 'vdebug', 'log', warn', 'error')") } }Janus.log('Initializing library'); var r = e.dependencies || Janus.useDefaultDependencies(); Janus.isArray = r.isArray, Janus.webRTCAdapter = r.webRTCAdapter, Janus.httpAPICall = r.httpAPICall, Janus.checkJanusExtension = r.checkJanusExtension, Janus.newWebSocket = r.newWebSocket, Janus.listDevices = function(i, e) { i = typeof i === 'function' ? i : Janus.noop, e == null && (e = { audio: !0, video: !0 }), navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(e).then(function(a) { navigator.mediaDevices.enumerateDevices().then(function(e) { Janus.debug(e), i(e); try { var t; var n = a.getTracks(); for (t in n) { var r = n[t]; r != null && r.stop() } } catch (e) {} }) }).catch(function(e) { Janus.error(e), i([]) }) : (Janus.warn('navigator.mediaDevices unavailable'), i([])) }, Janus.attachMediaStream = function(e, t) { Janus.webRTCAdapter.browserDetails.browser !== 'chrome' || Janus.webRTCAdapter.browserDetails.version >= 43 ? e.srcObject = t : void 0 !== e.src ? e.src = URL.createObjectURL(t) : Janus.error('Error attaching stream to element') }, Janus.reattachMediaStream = function(e, t) { Janus.webRTCAdapter.browserDetails.browser !== 'chrome' || Janus.webRTCAdapter.browserDetails.version >= 43 ? e.srcObject = t.srcObject : void 0 !== e.src ? e.src = t.src : Janus.error('Error reattaching stream to element') }; var a = window.onbeforeunload; window.onbeforeunload = function() { for (var e in Janus.log('Closing window'), Janus.sessions)Janus.sessions[e] !== null && void 0 !== Janus.sessions[e] && Janus.sessions[e].destroyOnUnload && (Janus.log('Destroying session ' + e), Janus.sessions[e].destroy({ asyncRequest: !1 })); a && typeof a === 'function' && a() }, Janus.initDone = !0, e.callback() } }, Janus.isWebrtcSupported = function() { return void 0 !== window.RTCPeerConnection && window.RTCPeerConnection !== null && void 0 !== navigator.getUserMedia && navigator.getUserMedia !== null }, Janus.randomString = function(e) { for (var t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', n = '', r = 0; r < e; r++) { var a = Math.floor(Math.random() * t.length); n += t.substring(a, a + 1) } return n }
